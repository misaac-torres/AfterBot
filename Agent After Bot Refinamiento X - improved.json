{
  "name": "Agent After Bot Refinamiento",
  "nodes": [
    {
      "parameters": {
        "updates": [
          "message"
        ],
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1.2,
      "position": [
        -3024,
        1888
      ],
      "id": "9afe69fa-f585-43a5-85b0-17c191052f35",
      "name": "Telegram Trigger Delta",
      "webhookId": "04c71877-095c-499a-a5a2-cac9669b5810",
      "credentials": {
        "telegramApi": {
          "id": "X4qyKQtMSdDRIqOu",
          "name": "Agent After Bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * TG Normalize n Route Intent v4.3 (PATCH: respuestas no se van a Alignment cuando el objetivo es AFTER)\n * Mantiene lo que ya funciona y corrige SOLO esto:\n * 1) Si el usuario responde A1/A2... y pone /after (al final o en l√≠nea aparte),\n *    esas l√≠neas NO son ‚Äúidea‚Äù; son clarify_answers_text para el AFTER LLM.\n * 2) Si estamos en modo AFTER y el usuario manda respuestas (A1/A2...) SIN comando,\n *    se enruta a intent=\"after\" + after_action=\"continue\" (no a alignment).\n * 3) Se asegura output.idea_text ‚Äúvivo‚Äù para el AFTER LLM (sin contaminarlo con respuestas).\n *\n * NOTA: no crea nodos nuevos, no cambia routing_key, no cambia reglas de greeting/reset.\n */\n\nfunction coalesce(...args) { for (const v of args) if (v !== undefined && v !== null && v !== \"\") return v; return null; }\nfunction normStr(s) { return (s ?? \"\").toString().trim(); }\nfunction normLower(s) { return normStr(s).toLowerCase(); }\nfunction isObj(v) { return typeof v === \"object\" && v !== null && !Array.isArray(v); }\n\nfunction getIncomingText(j) {\n  const tgText = coalesce(j.message?.text, j.callback_query?.data, j.text);\n  return normStr(coalesce(j._user_text, j.output?._user_text, tgText, j.body?.text, \"\"));\n}\n\nfunction getReplyText(j){\n  return normStr(\n    coalesce(\n      j.reply_text,\n      j.message?.reply_to_message?.text,\n      j.callback_query?.message?.reply_to_message?.text,\n      \"\"\n    )\n  );\n}\n\nfunction getChatId(j) {\n  const tgChatId = coalesce(j.message?.chat?.id, j.callback_query?.message?.chat?.id);\n  const cid = coalesce(j.chat_id, j.output?.chat_id, tgChatId, null);\n  return (cid === null || cid === undefined) ? null : cid;\n}\n\nfunction extractInbound(j){\n  const raw_text = getIncomingText(j);\n  const reply_text = getReplyText(j);\n  const chat_id = getChatId(j);\n  const routing_key = normStr((chat_id !== null && chat_id !== undefined) ? `tg:${chat_id}` : \"tg:unknown\");\n  return { raw_text, reply_text, chat_id, routing_key };\n}\n\n// ---------- Detectores ----------\nfunction detectGreetingLower(lower) {\n  if (!lower) return false;\n  const greetings = [\"hola\",\"buenas\",\"buenos dias\",\"buenas tardes\",\"buenas noches\",\"hi\",\"hello\",\"hey\",\"que tal\",\"qu√© tal\",\"buen d√≠a\",\"buen dia\"];\n  if (greetings.includes(lower)) return true;\n  if (lower.length <= 18 && greetings.some(g => lower.startsWith(g))) return true;\n  return false;\n}\n\n// comando como token de l√≠nea\nfunction hasLineCommand(text, cmd) {\n  const t = (text ?? \"\").toString();\n  const re = new RegExp(`(^|\\\\n)\\\\s*\\\\/${cmd}(\\\\s|$)`, \"i\");\n  return re.test(t);\n}\n\nfunction detectAfterAction(raw, lower) {\n  const safeRaw = normStr(raw);\n  const t = lower ?? normLower(safeRaw);\n\n  // brief ejecutivo (alias)\n  if (hasLineCommand(safeRaw, \"refinebrief\") || t.startsWith(\"/refinebrief\")) return \"brief\";\n  if (hasLineCommand(safeRaw, \"briefejecutivo\") || t.startsWith(\"/briefejecutivo\")) return \"brief\";\n  if (hasLineCommand(safeRaw, \"brief\") || t.includes(\"after brief\") || t.includes(\"generar brief\") || t.includes(\"after_brief\")) return \"brief\";\n\n  // continue / clarify\n  if (hasLineCommand(safeRaw, \"continue\") || hasLineCommand(safeRaw, \"continuar\") || t.includes(\"after_continue\")) return \"continue\";\n  if (hasLineCommand(safeRaw, \"clarify\") || hasLineCommand(safeRaw, \"aclarar\") || t.includes(\"after_clarify\")) return \"clarify\";\n\n  // after refine\n  if (hasLineCommand(safeRaw, \"after\") || t.includes(\"after_refine\")) return \"refine\";\n\n  // inline\n  if (t.startsWith(\"/brief\") || t.startsWith(\"/refinebrief\")) return \"brief\";\n  if (t.startsWith(\"/continue\") || t.startsWith(\"/continuar\")) return \"continue\";\n  if (t.startsWith(\"/clarify\") || t.startsWith(\"/aclarar\")) return \"clarify\";\n  if (t.startsWith(\"/after\") || t.startsWith(\"after:\") || t.startsWith(\"after \")) return \"refine\";\n\n  return null;\n}\n\n/**\n * Mantiene tu regla original:\n * - continue/clarify => alignment\n * - refine/brief => after\n */\nfunction detectIntentAndAction(text) {\n  const raw = normStr(text);\n  const lower = normLower(raw);\n\n  if (hasLineCommand(raw, \"reset\") || lower.startsWith(\"/reset\")) return { intent: \"greeting\", after_action: null, reset: true };\n  if (detectGreetingLower(lower)) return { intent: \"greeting\", after_action: null, reset: false };\n\n  const after_action = detectAfterAction(raw, lower);\n\n  if (after_action === \"continue\" || after_action === \"clarify\") {\n    return { intent: \"alignment\", after_action, reset: false };\n  }\n\n  if (after_action) return { intent: \"after\", after_action, reset: false };\n\n  return { intent: \"alignment\", after_action: null, reset: false };\n}\n\n// Remueve l√≠neas que sean SOLO comandos, para obtener body_text real\nfunction stripCommandLines(raw) {\n  const lines = (raw ?? \"\").toString().split(\"\\n\");\n  const cmdRe = /^\\s*\\/(after|brief|briefejecutivo|refinebrief|continue|continuar|clarify|aclarar|reset)\\s*$/i;\n  const kept = lines.filter(l => !cmdRe.test(l));\n  return normStr(kept.join(\"\\n\"));\n}\n\nfunction looksLikeAnswers(t){\n  const x = normStr(t);\n  if (!x) return false;\n  if (/^(A1:|A2:|A3:|A4:|A5:|A6:|A7:|A8:|Q1:|Q2:|Q3:|Q4:|Q5:|Q6:|Q7:|Q8:)/i.test(x)) return true;\n  if (x.includes(\"\\nA1:\") || x.includes(\"\\nA2:\") || x.includes(\"\\nQ1:\")) return true;\n  return false;\n}\n\n// Entrada n8n Cloud safe\nconst inItems = (typeof items !== \"undefined\" && Array.isArray(items)) ? items : $input.all();\nconst out = [];\n\nconst store = $getWorkflowStaticData(\"global\");\nif (!isObj(store.threads)) store.threads = {};\n\nfor (const it of inItems) {\n  const j = isObj(it.json) ? it.json : {};\n  const { raw_text, reply_text, chat_id, routing_key } = extractInbound(j);\n\n  if (!store.threads[routing_key]) {\n    store.threads[routing_key] = {\n      refinement_pass: 0,\n      last_state: \"\",\n      last_switch_key: \"\",\n      mode: \"alignment\",\n      user_email: \"\",\n      seed_alignment_idea: \"\",\n      last_alignment_idea: \"\",\n      last_approved_alignment_idea: \"\",\n      last_clarify_answers_text: \"\",\n      awaiting_clarify_answers: false,\n      last_alignment_gate: \"\",\n      last_alignment_score_total: 0,\n      last_alignment_power_questions: []\n    };\n  }\n  const thread = store.threads[routing_key];\n\n  let { intent, after_action, reset } = detectIntentAndAction(raw_text);\n\n  // body_text = mensaje sin l√≠neas de comandos\n  const body_text = stripCommandLines(raw_text);\n\n  const isAnswersRaw = looksLikeAnswers(raw_text);\n  const isAnswersBody = looksLikeAnswers(body_text);\n\n  // Base idea ‚Äúviva‚Äù (para AFTER LLM)\n  const aliveIdea = normStr(coalesce(\n    thread.last_approved_alignment_idea,\n    thread.last_alignment_idea,\n    thread.seed_alignment_idea,\n    j.last_alignment_idea,\n    j.seed_alignment_idea,\n    \"\"\n  ));\n\n  // Default\n  let _user_text = raw_text;\n\n  // ===============================\n  // PATCH 1: /after con body que SON respuestas (A1/A2...) -> NO contaminar idea\n  // - Antes: intent=after y body_text => _user_text=body_text (se iba con respuestas como si fuera idea)\n  // - Ahora: si body_text parece respuestas, lo tratamos como clarify_answers_text y mantenemos idea viva en _user_text\n  // ===============================\n  let captured_after_answers = \"\";\n  const isAfterCmd = (intent === \"after\" && (after_action === \"refine\" || after_action === \"brief\"));\n\n  if (isAfterCmd && body_text && isAnswersBody) {\n    captured_after_answers = body_text;\n    _user_text = aliveIdea || body_text; // si no hay idea viva (caso raro), al menos no mandamos \"/after\"\n  } else {\n    // comportamiento anterior: /after con body (idea) => body es idea\n    if (intent === \"after\" && after_action && body_text) {\n      _user_text = body_text;\n    }\n  }\n\n  // ‚úÖ /continue con body => respuestas (para alignment clarify followup)\n  if (intent === \"alignment\" && after_action === \"continue\" && body_text) {\n    _user_text = body_text;\n    thread.last_clarify_answers_text = body_text;\n  }\n\n  // ‚úÖ /clarify con body => idea (para alignment)\n  if (intent === \"alignment\" && after_action === \"clarify\" && body_text) {\n    _user_text = body_text;\n  }\n\n  // ‚úÖ /after o /brief sin body -> idea persistida\n  const isCommandOnlyAfter = (intent === \"after\" && (after_action === \"refine\" || after_action === \"brief\") && !body_text);\n  if (isCommandOnlyAfter) {\n    _user_text = normStr(\n      coalesce(\n        thread.last_approved_alignment_idea,\n        thread.last_alignment_idea,\n        thread.seed_alignment_idea,\n        j.last_alignment_idea,\n        j.seed_alignment_idea,\n        reply_text,\n        \"\"\n      )\n    );\n  }\n\n  // Persistir respuestas de Clarify si ven√≠amos esperando respuestas y llegan en crudo\n  if (intent === \"alignment\" && thread.awaiting_clarify_answers && isAnswersRaw) {\n    thread.last_clarify_answers_text = raw_text;\n  }\n\n  // ===============================\n  // PATCH 2: si estamos en modo AFTER y llegan respuestas sin comando -> route a AFTER (no alignment)\n  // - Evita que el usuario ‚Äúcaiga‚Äù al Alignment LLM por solo contestar A1/A2...\n  // ===============================\n  if (intent === \"alignment\" && !after_action && normLower(thread.mode) === \"after\" && isAnswersRaw) {\n    intent = \"after\";\n    after_action = \"continue\";\n    captured_after_answers = raw_text;     // respuestas para AFTER LLM\n    _user_text = aliveIdea || raw_text;    // idea viva como input principal\n  }\n\n  // Se√±al robusta de follow-up para el LLM Alignment:\n  const is_clarify_followup =\n    (intent === \"alignment\" && after_action === \"continue\") ||\n    (intent === \"alignment\" && thread.awaiting_clarify_answers && isAnswersRaw);\n\n  const clarify_answers_text_alignment = normStr(coalesce(\n    (intent === \"alignment\" && after_action === \"continue\" && body_text) ? body_text : null,\n    thread.last_clarify_answers_text,\n    \"\"\n  ));\n\n  // AFTER answers (para AFTER LLM)\n  const clarify_answers_text_after = normStr(coalesce(\n    captured_after_answers,\n    \"\" // no heredamos thread.last_clarify_answers_text aqu√≠ para no mezclar con Alignment\n  ));\n\n  // Propagar contexto de thread al payload\n  const output = isObj(j.output) ? j.output : {};\n  output.chat_id = chat_id;\n  output._user_text = _user_text;\n  output.routing_key = routing_key;\n\n  output.intent = intent;\n  output.after_action = after_action;\n  output.reset = !!reset;\n\n  // ‚úÖ Idea viva expl√≠cita (para LLM AFTER / Post-Merge)\n  output.idea_text = aliveIdea || normStr(coalesce(output.idea_text, \"\"));\n\n  // Contexto persistido\n  output.seed_alignment_idea = thread.seed_alignment_idea || \"\";\n  output.last_alignment_idea = thread.last_alignment_idea || \"\";\n  output.last_approved_alignment_idea = thread.last_approved_alignment_idea || \"\";\n  output.last_clarify_answers_text = thread.last_clarify_answers_text || \"\";\n\n  // Alignment follow-up\n  output.is_clarify_followup = !!is_clarify_followup;\n  output.clarify_answers_text = (intent === \"alignment\") ? clarify_answers_text_alignment : clarify_answers_text_after;\n\n  output.thread_state = {\n    awaiting_clarify_answers: !!thread.awaiting_clarify_answers,\n    last_alignment_gate: normStr(thread.last_alignment_gate || \"\"),\n    last_alignment_score_total: Number(thread.last_alignment_score_total || 0),\n    last_alignment_power_questions: Array.isArray(thread.last_alignment_power_questions) ? thread.last_alignment_power_questions : [],\n    mode: normStr(thread.mode || \"\")\n  };\n\n  const top = { ...j };\n  top.chat_id = chat_id;\n  top._user_text = _user_text;\n  top.routing_key = routing_key;\n  top.intent = intent;\n  top.after_action = after_action;\n  top.reset = !!reset;\n  top.reply_text = reply_text;\n  top.output = output;\n\n  if (!isObj(output.chat)) output.chat = {};\n  if (!output.chat.id && chat_id !== null && chat_id !== undefined) output.chat.id = chat_id;\n\n  out.push({ json: top });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2800,
        1888
      ],
      "id": "eec18b14-ce89-4e77-902a-31a990465572",
      "name": "TG Pre-route Normalizer + Edits2"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "d8b45618-dd3e-4d03-807b-03e939dec131",
                    "leftValue": "={{ $json.intent }}",
                    "rightValue": "alignment",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "ee697e6d-07d9-414c-8f9f-0de79547a2a0",
                    "leftValue": "={{ $json.intent }}",
                    "rightValue": "greeting",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "5712d032-104b-4dca-a64c-ee992b8e1ff2",
                    "leftValue": "={{ $json.intent }}",
                    "rightValue": "after",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        -2576,
        1872
      ],
      "id": "587f42a3-7b26-4812-aed9-7c841aecfbb0",
      "name": "Switch Route"
    },
    {
      "parameters": {
        "numberInputs": 3
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1088,
        1872
      ],
      "id": "3158cea3-486d-4311-bf1a-870ae4eccd4f",
      "name": "Merge LLMs"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Post-Merge Organizer + Switch Enricher ‚Äî v1.6.6 (REHYDRATE AFTER ON /BRIEF)\n * FIX v1.6.6:\n * - Guarda en thread.last_after_result el √∫ltimo after_result completo.\n * - Si llega /briefejecutivo SIN payload AFTER (solo Telegram/Normalize), rehidrata finalOut.after_result desde el cache.\n * - Si el cache indica brief_ready=true, enruta a brief.ejecutivo aunque en este item no venga el payload.\n * - Mantiene todo lo existente (AUTO after_brief + scorecard prop + latch).\n */\n\nfunction coalesce(...args){ for (const v of args) if (v !== undefined && v !== null && v !== \"\") return v; return null; }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\nfunction normLower(s){ return normStr(s).toLowerCase(); }\nfunction normArr(a, max=12){ return Array.isArray(a) ? a.map(x=>normStr(x)).filter(Boolean).slice(0,max) : []; }\n\nfunction safeParseJSON(maybe){\n  if (isObj(maybe)) return maybe;\n  if (typeof maybe === \"string\"){\n    try { return JSON.parse(maybe); } catch(_){}\n    const s = maybe.indexOf(\"{\"), e = maybe.lastIndexOf(\"}\");\n    if (s >= 0 && e > s) { try { return JSON.parse(maybe.slice(s, e+1)); } catch(_){} }\n  }\n  return null;\n}\n\nfunction toNumScore(v, fallback=0){\n  if (typeof v === \"number\" && Number.isFinite(v)) return v;\n  if (typeof v === \"string\"){\n    const m = v.match(/-?\\d+(\\.\\d+)?/);\n    if (m) {\n      const n = Number(m[0]);\n      if (Number.isFinite(n)) return n;\n    }\n  }\n  return fallback;\n}\n\nfunction extractChatIdFromRoutingKey(rk){\n  const s = normStr(rk);\n  const m = s.match(/^tg:(\\d{3,})$/);\n  return m ? m[1] : null;\n}\n\nfunction extractTelegramChatId(j){\n  const cand = coalesce(\n    j.chat_id,\n    j.chatId,\n    j.context?.chat?.id,\n    j.context?.chat_id,\n    j.message?.chat?.id,\n    j.message?.chat_id,\n    j.callback_query?.message?.chat?.id,\n    j.update?.message?.chat?.id,\n    j.update?.callback_query?.message?.chat?.id,\n    j.data?.chat?.id,\n    j.data?.chat_id,\n    j.output?.chat_id\n  );\n\n  if (typeof cand === \"number\" && Number.isFinite(cand)) return String(cand);\n  const s = normStr(cand);\n  if (s && /^\\d{3,}$/.test(s)) return s;\n\n  const rk = coalesce(j.routing_key, j.output?.routing_key, null);\n  return extractChatIdFromRoutingKey(rk) || null;\n}\n\n/** SOLO texto real de Telegram (para comandos) */\nfunction extractUserCommandTextTelegramOnly(j){\n  return normStr(coalesce(\n    j.message?.text,\n    j.message?.caption,\n    j.update?.message?.text,\n    j.update?.message?.caption,\n    j.callback_query?.data,\n    j.update?.callback_query?.data,\n    \"\"\n  ));\n}\n\n/** Fallback controlado: usa _user_text SOLO si empieza con \"/\" */\nfunction extractUserCommandTextFallback(j){\n  const shadow = normStr(coalesce(\n    j._user_text,\n    j.text,\n    j.output?._user_text,\n    j.context?._user_text,\n    \"\"\n  ));\n  if (/^\\//.test(shadow) && shadow.length <= 80) return shadow;\n  return \"\";\n}\n\n/** Inferir comando por fields normalizados */\nfunction inferCommandFromNormalizedFields(j){\n  const intent = normLower(coalesce(j.intent, j.output?.intent, \"\"));\n  const after_action = normLower(coalesce(j.after_action, j.output?.after_action, \"\"));\n  if (intent === \"after\" && after_action === \"brief\") return \"/briefejecutivo\";\n  if (intent === \"after\" && after_action === \"refine\") return \"/after\";\n  if (intent === \"alignment\" && after_action === \"continue\") return \"/continue\";\n  if (intent === \"alignment\" && after_action === \"clarify\") return \"/clarify\";\n  return \"\";\n}\n\nfunction extractInboundText(j){\n  const telegramText = extractUserCommandTextTelegramOnly(j);\n  const commandText = normStr(\n    telegramText ||\n    inferCommandFromNormalizedFields(j) ||\n    extractUserCommandTextFallback(j)\n  );\n\n  const rawText = normStr(coalesce(\n    telegramText,\n    j._user_text,\n    j.output?._user_text,\n    j.output?.text,\n    \"\"\n  ));\n\n  return { commandText, rawText };\n}\n\nfunction extractLLMPayload(j){\n  if (!isObj(j)) return null;\n\n  // Caso t√≠pico: viene todo en output plano (como tu input)\n  if (isObj(j.output) && (\n      j.output.state || j.output.gate ||\n      j.output.feature_title || j.output.executive_summary ||\n      j.output.brief_ready !== undefined ||\n      j.output.next_user_instruction ||\n      j.output.sprint_plan || j.output.user_stories ||\n      // OJO: aqu√≠ tambi√©n puede venir after_result ya armado por nodos previos\n      j.output.after_result\n  )) return j.output;\n\n  if (j.state || j.gate) return j;\n\n  const content = j?.choices?.[0]?.message?.content;\n  if (content){\n    const parsed = safeParseJSON(content);\n    if (parsed) return parsed.output ? parsed.output : parsed;\n  }\n\n  const maybe = coalesce(j.data, j.result, j.response, j.message, null);\n  const parsed2 = safeParseJSON(maybe);\n  if (parsed2) return parsed2.output ? parsed2.output : parsed2;\n\n  return null;\n}\n\nfunction buildFinalEnvelope(j, ap, rawUserText){\n  const chat_id = coalesce(\n    extractTelegramChatId(j),\n    ap?.chat_id,\n    j.output?.thread_state?.last_chat_id,\n    j.thread_state?.last_chat_id,\n    null\n  );\n\n  const idea_text = normStr(coalesce(\n    ap?.idea_text,\n    j.output?.idea_text,\n    j.idea_text,\n    \"\"\n  ));\n\n  const _user_text = normStr(coalesce(\n    rawUserText,\n    idea_text,\n    ap?._user_text,\n    j.output?._user_text,\n    \"\"\n  ));\n\n  const routing_key = chat_id ? `tg:${chat_id}` : normStr(coalesce(j.routing_key, j.output?.routing_key, \"tg:unknown\"));\n\n  const intent = normLower(coalesce(j.intent, j.output?.intent, \"\"));\n  const after_action = normLower(coalesce(j.after_action, j.output?.after_action, \"\"));\n\n  const _reset = !!coalesce(j.output?._reset, j._reset, j.output?.reset, j.reset, false);\n\n  return {\n    chat_id,\n    _user_text,\n    idea_text,\n    routing_key,\n    intent: intent || null,\n    after_action: after_action || null,\n    route: null,\n    _reset,\n\n    state: null,\n    gate: null,\n    alignment: null,\n    after_result: null,\n    brief: null,\n    error_message: \"\"\n  };\n}\n\n/** AUTO infer AFTER_BRIEF cuando el LLM ya pide /briefejecutivo */\nfunction inferAfterBriefReady(ap){\n  if (!isObj(ap)) return false;\n\n  if (ap.brief_ready === true) return true;\n\n  const nui = normLower(coalesce(ap.next_user_instruction, \"\"));\n  if (nui.includes(\"/briefejecutivo\") || nui.includes(\"briefejecutivo\")) return true;\n\n  const gaps = Array.isArray(ap.gaps_blocking_ready) ? ap.gaps_blocking_ready : [];\n  const qs   = Array.isArray(ap.questions) ? ap.questions : [];\n  const hasPlan = Array.isArray(ap.sprint_plan) && ap.sprint_plan.length > 0;\n  const hasStories = Array.isArray(ap.user_stories) && ap.user_stories.length > 0;\n  const hasSummary = typeof ap.executive_summary === \"string\" && normStr(ap.executive_summary).length > 40;\n\n  if (gaps.length === 0 && qs.length === 0 && hasPlan && hasStories && hasSummary) return true;\n\n  return false;\n}\n\nfunction readyFromPayload(j, ap){\n  return (\n    ap?.brief_ready === true ||\n    j?.output?.after_result?.brief_ready === true ||\n    j?.output?.brief_ready === true ||\n    inferAfterBriefReady(ap) === true\n  );\n}\n\nfunction isBriefReady(thread, ap, j){\n  return (\n    thread?.last_after_brief_ready === true ||\n    readyFromPayload(j, ap) ||\n    (isObj(thread?.last_after_result) && thread.last_after_result.brief_ready === true)\n  );\n}\n\nfunction computeSwitchKey(finalOut){\n  if (finalOut.intent === \"greeting\" || finalOut.route === \"greeting\") return \"greeting\";\n  if (finalOut.route === \"brief.ejecutivo\") return \"brief.ejecutivo\";\n\n  const gate = normStr(finalOut.gate || \"\");\n  const state = normStr(finalOut.state || \"\");\n\n  if (gate === \"after_refine\") return \"alignment.after_refine\";\n  if (gate === \"clarify\") return \"alignment.clarify\";\n  if (gate === \"discard\") return \"alignment.discard\";\n  if (gate) return \"alignment.unknown_gate\";\n\n  if (state === \"after_refinement\") return \"after.after_refinement\";\n  if (state === \"after_brief\") return \"after.after_brief\";\n\n  if (state === \"error\") return \"error\";\n  return \"fallback\";\n}\n\nconst store = $getWorkflowStaticData(\"global\");\nif (!isObj(store.threads)) store.threads = {};\n\nconst out = [];\nconst inItems = (typeof items !== \"undefined\" && Array.isArray(items)) ? items : $input.all();\n\nfor (const it of inItems){\n  const j = isObj(it.json) ? it.json : {};\n  const ap = extractLLMPayload(j);\n  const { commandText, rawText } = extractInboundText(j);\n  const finalOut = buildFinalEnvelope(j, ap, rawText);\n\n  const rk = finalOut.chat_id ? `tg:${finalOut.chat_id}` : (finalOut.routing_key || \"tg:unknown\");\n  finalOut.routing_key = rk;\n\n  if (!store.threads[rk]) {\n    store.threads[rk] = {\n      refinement_pass: 0, last_state: \"\", last_switch_key: \"\", mode: \"alignment\", user_email: \"\",\n      seed_alignment_idea: \"\",\n      last_alignment_idea: \"\",\n      last_approved_alignment_idea: \"\",\n      last_clarify_answers_text: \"\",\n      awaiting_clarify_answers: false,\n      last_alignment_gate: \"\",\n      last_alignment_score_total: 0,\n      last_alignment_power_questions: [],\n      last_after_brief_ready: false,\n      last_after_result: null,          // ‚úÖ NUEVO cache\n      last_chat_id: finalOut.chat_id ? String(finalOut.chat_id) : \"\",\n      pending_brief_request: false\n    };\n  }\n\n  const thread = store.threads[rk];\n  if (finalOut.chat_id) thread.last_chat_id = String(finalOut.chat_id);\n\n  // Comando: Telegram OR inferido OR fallback slash\n  const userCmdText = normStr(commandText);\n  const t = normLower(userCmdText);\n\n  // Reset\n  const wantsReset = finalOut._reset || t === \"/reset\" || t.startsWith(\"/reset \");\n  if (wantsReset) {\n    store.threads[rk] = {\n      refinement_pass: 0, last_state: \"\", last_switch_key: \"\", mode: \"alignment\", user_email: \"\",\n      seed_alignment_idea: \"\", last_alignment_idea: \"\", last_approved_alignment_idea: \"\",\n      last_clarify_answers_text: \"\", awaiting_clarify_answers: false,\n      last_alignment_gate: \"\", last_alignment_score_total: 0, last_alignment_power_questions: [],\n      last_after_brief_ready: false,\n      last_after_result: null,\n      last_chat_id: thread.last_chat_id || \"\",\n      pending_brief_request: false\n    };\n\n    finalOut.route = \"greeting\";\n    finalOut.intent = \"greeting\";\n    finalOut.after_action = null;\n\n    finalOut.switch_key = \"greeting\";\n    finalOut.thread_state = { routing_key: rk, ...store.threads[rk] };\n    out.push({ json: { output: finalOut } });\n    continue;\n  }\n\n  // Greeting directo\n  if (finalOut.intent === \"greeting\") {\n    finalOut.route = \"greeting\";\n    finalOut.state = \"greeting\";\n    finalOut.switch_key = \"greeting\";\n    thread.last_switch_key = \"greeting\";\n    thread.last_state = \"greeting\";\n    finalOut.thread_state = { routing_key: rk, ...thread };\n    out.push({ json: { output: finalOut } });\n    continue;\n  }\n\n  // ‚úÖ FIX CLAVE: si llega /briefejecutivo pero este item no trae AFTER, rehidrata desde thread\n  const isBriefCmd =\n    /^\\/briefejecutivo(\\s|@|$)/i.test(userCmdText) ||\n    /^\\/brief(\\s|@|$)/i.test(userCmdText);\n\n  if (isBriefCmd) {\n    thread.pending_brief_request = true;\n\n    const readyNow = isBriefReady(thread, ap, j) || (normStr(thread.last_state || \"\") === \"after_brief\");\n\n    if (readyNow) {\n      // Enruta a brief\n      finalOut.route = \"brief.ejecutivo\";\n      finalOut.state = \"after_brief\";\n      finalOut.switch_key = \"brief.ejecutivo\";\n      thread.pending_brief_request = false;\n\n      // ‚úÖ Rehidratar datos para el nodo HTML (aunque no venga payload en esta ejecuci√≥n)\n      if (!isObj(finalOut.after_result) && isObj(thread.last_after_result)) {\n        finalOut.after_result = thread.last_after_result;\n      }\n      if (isObj(finalOut.after_result)) finalOut.after_result.brief_ready = true;\n\n    } else {\n      // Mantenerse en after_brief esperando ready\n      finalOut.route = null;\n      finalOut.state = \"after_brief\";\n      finalOut.switch_key = \"after.after_brief\";\n    }\n\n    thread.last_switch_key = String(finalOut.switch_key || \"\");\n    thread.last_state = String(finalOut.state || \"\");\n    finalOut.thread_state = { routing_key: rk, ...thread };\n    out.push({ json: { output: finalOut } });\n    continue;\n  }\n\n  // Reminder: falta comando expl√≠cito del usuario\n  const hasUserText = !!normStr(rawText);\n  const needsCommandReminder = !userCmdText && hasUserText;\n  if (needsCommandReminder) {\n    finalOut.state = \"alignment_result\";\n    finalOut.switch_key = \"fallback\";\n    finalOut.reminder_prompt = \"Recib√≠ tu respuesta, pero necesito un comando para continuar: usa /continue (Alignment), /after (refinar), /refinebrief (refinar + brief) o /briefejecutivo (brief).\";\n    thread.last_switch_key = \"fallback\";\n    thread.last_state = \"reminder\";\n    finalOut.thread_state = { routing_key: rk, ...thread };\n    out.push({ json: { output: finalOut } });\n    continue;\n  }\n\n  // fallback chat_id\n  if (!finalOut.chat_id && thread.last_chat_id){\n    finalOut.chat_id = String(thread.last_chat_id);\n    finalOut.routing_key = `tg:${finalOut.chat_id}`;\n  }\n\n  if (!finalOut.chat_id){\n    finalOut.state = \"error\";\n    finalOut.error_message = \"Falta chat_id. No puedo responder por Telegram.\";\n    finalOut.switch_key = \"error\";\n  } else {\n\n    // Procesar payload (AFTER / Alignment)\n    if (ap){\n      let apState = normStr(ap.state || \"\");\n\n      // Derivaci√≥n robusta de state\n      if (!apState) {\n        const isAfterLike =\n          typeof ap.feature_title === \"string\" ||\n          typeof ap.executive_summary === \"string\" ||\n          Array.isArray(ap.sprint_plan) ||\n          Array.isArray(ap.user_stories) ||\n          ap.brief_ready !== undefined ||\n          typeof ap.next_user_instruction === \"string\" ||\n          isObj(ap.after_result);\n\n        if (isAfterLike) {\n          const br = inferAfterBriefReady(ap);\n          apState = br ? \"after_brief\" : \"after_refinement\";\n          if (br) ap.brief_ready = true;\n        }\n      }\n\n      // ‚úÖ Si ya viene after_result armado, √∫salo directamente\n      if (isObj(ap.after_result)) {\n        finalOut.state = \"after_brief\";\n        finalOut.after_result = ap.after_result;\n        thread.last_after_brief_ready = (ap.after_result.brief_ready === true);\n        thread.last_after_result = ap.after_result;\n      }\n      else if (apState === \"after_refinement\" || apState === \"after_brief\") {\n        finalOut.state = apState;\n\n        const briefReady = !!coalesce(ap.brief_ready, (apState === \"after_brief\"), false);\n\n        finalOut.after_result = {\n          feature_title: normStr(coalesce(ap.feature_title, \"\")),\n          idea_text: normStr(coalesce(ap.idea_text, finalOut.idea_text, \"\")),\n          brief_ready: briefReady,\n          executive_summary: normStr(coalesce(ap.executive_summary, \"\")),\n          readiness_criteria_min: normArr(ap.readiness_criteria_min, 12),\n          checkpoints_obligatorios: normArr(ap.checkpoints_obligatorios, 12),\n          gaps_blocking_ready: Array.isArray(ap.gaps_blocking_ready) ? normArr(ap.gaps_blocking_ready, 12) : [],\n          key_dependencies: normArr(ap.key_dependencies, 12),\n          key_risks: normArr(ap.key_risks, 12),\n          recommended_kpis: normArr(ap.recommended_kpis, 12),\n          questions: normArr(ap.questions, 12),\n          macro_estimation_hours_total_range: ap.macro_estimation_hours_total_range || null,\n          sprint_plan: Array.isArray(ap.sprint_plan) ? ap.sprint_plan : [],\n          user_stories: Array.isArray(ap.user_stories) ? ap.user_stories : [],\n          next_user_instruction: normStr(coalesce(ap.next_user_instruction, \"\")),\n          impact_scorecard: Array.isArray(ap.impact_scorecard) ? ap.impact_scorecard : [],\n          impact_score_overall: isObj(ap.impact_score_overall) ? ap.impact_score_overall : null\n        };\n\n        // ‚úÖ Cachea SIEMPRE el after_result √∫ltimo v√°lido\n        thread.last_after_brief_ready = (briefReady === true);\n        thread.last_after_result = finalOut.after_result;\n\n        if (apState === \"after_brief\") {\n          finalOut.brief = ap.brief || ap.brief_ejecutivo || null;\n        }\n\n      } else {\n        // Alignment (igual)\n        const scoreCandidate = coalesce(ap.score_total, ap.scoreTotal, ap.score, ap.total_score, null);\n        const looksAlignment = (\n          ap.gate ||\n          ap.state === \"alignment_result\" ||\n          scoreCandidate !== null ||\n          ap.rationale !== undefined ||\n          Array.isArray(ap.power_questions)\n        );\n\n        if (looksAlignment){\n          finalOut.state = \"alignment_result\";\n          finalOut.gate = ap.gate ? normStr(ap.gate) : null;\n          finalOut.alignment = ap;\n\n          const normalizedScore = toNumScore(scoreCandidate, null);\n          if (Number.isFinite(normalizedScore)) {\n            const gateByScore = normalizedScore < 60 ? \"discard\" : (normalizedScore < 80 ? \"clarify\" : \"after_refine\");\n            finalOut.gate = gateByScore;\n            if (finalOut.alignment) {\n              if (finalOut.alignment.score_total === undefined || finalOut.alignment.score_total === null) {\n                finalOut.alignment.score_total = normalizedScore;\n              }\n              finalOut.alignment.gate = gateByScore;\n            }\n          }\n\n          const idea = normStr(coalesce(ap.idea_text, ap._user_text, \"\"));\n          if (idea) {\n            thread.last_alignment_idea = idea;\n            if (!thread.seed_alignment_idea) thread.seed_alignment_idea = idea;\n          }\n\n          thread.last_alignment_gate = normStr(finalOut.gate || \"\");\n          thread.last_alignment_score_total = toNumScore(scoreCandidate, 0);\n          thread.last_alignment_power_questions = Array.isArray(ap.power_questions) ? ap.power_questions : [];\n          thread.awaiting_clarify_answers = (finalOut.gate === \"clarify\");\n\n          if (finalOut.gate === \"after_refine\" && idea) thread.last_approved_alignment_idea = idea;\n        }\n      }\n    }\n\n    // LATCH consume: si pidieron brief y ahora est√° ready\n    if (thread.pending_brief_request === true) {\n      const readyNow = isBriefReady(thread, ap, j) || (normStr(thread.last_state || \"\") === \"after_brief\");\n\n      if (readyNow) {\n        finalOut.route = \"brief.ejecutivo\";\n        finalOut.state = \"after_brief\";\n        finalOut.switch_key = \"brief.ejecutivo\";\n        thread.pending_brief_request = false;\n\n        if (!isObj(finalOut.after_result) && isObj(thread.last_after_result)) {\n          finalOut.after_result = thread.last_after_result;\n        }\n        if (isObj(finalOut.after_result)) finalOut.after_result.brief_ready = true;\n      }\n    }\n\n    if (!finalOut.switch_key) finalOut.switch_key = computeSwitchKey(finalOut);\n  }\n\n  thread.last_switch_key = String(finalOut.switch_key || \"\");\n  thread.last_state = String(finalOut.state || \"\");\n\n  finalOut.thread_state = {\n    routing_key: rk,\n    refinement_pass: Number(thread.refinement_pass || 0),\n    last_state: normStr(thread.last_state || \"\"),\n    last_switch_key: normStr(thread.last_switch_key || \"\"),\n    mode: normStr(thread.mode || \"\"),\n    user_email: normStr(thread.user_email || \"\"),\n    seed_alignment_idea: normStr(thread.seed_alignment_idea || \"\"),\n    last_alignment_idea: normStr(thread.last_alignment_idea || \"\"),\n    last_approved_alignment_idea: normStr(thread.last_approved_alignment_idea || \"\"),\n    last_clarify_answers_text: normStr(thread.last_clarify_answers_text || \"\"),\n    awaiting_clarify_answers: !!thread.awaiting_clarify_answers,\n    last_alignment_gate: normStr(thread.last_alignment_gate || \"\"),\n    last_alignment_score_total: Number.isFinite(thread.last_alignment_score_total) ? thread.last_alignment_score_total : 0,\n    last_alignment_power_questions: Array.isArray(thread.last_alignment_power_questions) ? thread.last_alignment_power_questions : [],\n    last_after_brief_ready: (thread.last_after_brief_ready === true),\n    last_chat_id: normStr(thread.last_chat_id || \"\"),\n    pending_brief_request: (thread.pending_brief_request === true)\n  };\n\n  out.push({ json: { output: finalOut } });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -832,
        1888
      ],
      "id": "366b3c43-1f5c-47d0-85d2-5b561574fbbf",
      "name": "Post-Merge Organizer + Switch Enricher3"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{$json.output.switch_key}}",
                    "rightValue": "alignment.after_refine",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    },
                    "id": "bc41d2d4-5a7b-4c17-b430-f08bb74ac887"
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "d77596a4-930a-4652-bb0e-d7638e47d8b1",
                    "leftValue": "={{$json.output.switch_key}}",
                    "rightValue": "alignment.clarify",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "f0c90ffb-f73d-42c5-a875-a9bd66c69b7b",
                    "leftValue": "={{$json.output.switch_key}}",
                    "rightValue": "alignment.discard",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "e86b3091-106f-43e3-825b-4be0d248e032",
                    "leftValue": "={{$json.output.switch_key}}",
                    "rightValue": "after.after_refinement",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "73b0d1f0-1ae8-4fd5-9d20-271c1f6a5927",
                    "leftValue": "={{$json.output.switch_key}}",
                    "rightValue": "greeting",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "1f245156-1727-4f23-b83b-cb7e8fcc48bd",
                    "leftValue": "={{$json.output.switch_key}}",
                    "rightValue": "error",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "9e684244-1f77-41d7-94ab-56421e5a6b97",
                    "leftValue": "={{$json.output.switch_key}}",
                    "rightValue": "fallback",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "6427e90e-2211-4dd4-b473-7213b08384d0",
                    "leftValue": "={{$json.output.switch_key}}",
                    "rightValue": "after.after_brief",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "fb306d71-d30b-4d14-a4a6-080526754a79",
                    "leftValue": "={{$json.output.switch_key}}",
                    "rightValue": "brief.ejecutivo",
                    "operator": {
                      "type": "string",
                      "operation": "equals",
                      "name": "filter.operator.equals"
                    }
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        -576,
        1776
      ],
      "id": "6d898301-be35-4674-9592-a463316bf489",
      "name": "Switch"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Build Telegram Response ‚Äî greeting v1.2 (n8n Cloud safe)\n * - Responde cuando switch_key=\"greeting\"\n * - Incluye: qu√© es AFTER, plus del Alignment Engine (digitaliza visi√≥n GTM)\n * - Si viene reset_done=true: confirma reinicio (mismo camino greeting, sin LLM)\n * - CTA: luego del greeting SIEMPRE pedir /continue (solo en greeting)\n *\n * Input:  $json.output (Post-Merge envelope)\n * Output: $json.output.telegram.send_text + $json.output.telegram.chat_id\n */\n\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\n\nconst inItems = $input.all();\nconst out = [];\n\nfor (const it of inItems) {\n  const root = isObj(it.json) ? it.json : {};\n  const o = isObj(root.output) ? root.output : {};\n  const chat_id = o.chat_id;\n\n  const resetDone = !!o.reset_done;\n\n  const intro = resetDone\n    ? \"‚ôªÔ∏è Listo, reinici√© el hilo. Volvemos a cero.\\n\"\n    : \"üëã Hola, soy AFTER.\\n\";\n\n  const msg =\n`${intro}\nüöÄ ¬øQu√© es AFTER?\nAFTER convierte una idea en un plan ejecutable para BRP: hip√≥tesis, piloto, roadmap por sprints y macro-estimaci√≥n en HUs (con horas, dependencias y criterios de aceptaci√≥n).\n\nüß≠ ¬øPor qu√© existe el Alignment Engine?\nPorque digitaliza la visi√≥n de Direcci√≥n GTM (en este caso). Eval√∫a si tu idea realmente impacta caja/FCF, EBITDA, churn y NPS, y si es viable con evidencia ‚Äî antes de gastar tiempo y energ√≠a.\n\nüìå Env√≠ame una idea en este formato (corto y concreto):\nIdea: ...\nObjetivo: ...\nKPI rey: ... (con umbral)\nVentana: ... (ej: 60 d√≠as)\nDependencia #1: ...\nAlcance IN: ...\nAlcance OUT: ...\n\n‚úÖ Ejemplo (muy concreto):\nIdea: Atenci√≥n h√≠brida IA + agente para casos complejos\nObjetivo: Reducir transferencias y subir resoluci√≥n en primer contacto\nKPI rey: Transfer Rate -20% y FCR complejo +10%\nVentana: 60 d√≠as\nDependencia #1: Integraci√≥n con CRM + plataforma contact center\nAlcance IN: WhatsApp + Fibra (casos complejos), monitoreo y rescate humano\nAlcance OUT: Reemplazar agentes, cambios de pricing o canal f√≠sico\n\nüëâ Ahora env√≠a tu idea con ese formato y luego escribe /continue üòä\n(En greeting, /continue es obligatorio para arrancar evaluaci√≥n.)`;\n\n  if (!isObj(o.telegram)) o.telegram = {};\n  o.telegram.chat_id = chat_id;\n  o.telegram.send_text = msg;\n\n  root.output = o;\n  out.push({ json: root });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        1904
      ],
      "id": "1d0f06a7-e2b5-4077-8b6b-89ae720ad85d",
      "name": "Build Telegram Response Greeting"
    },
    {
      "parameters": {
        "chatId": "={{ $json.output.telegram.chat_id }}",
        "text": "={{ $json.output.telegram.send_text }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        -16,
        1904
      ],
      "id": "24a9ec23-538c-4c27-83e3-101ff8845c34",
      "name": "greeting",
      "webhookId": "ad341579-20e1-4502-a663-98e9ed0385ba",
      "credentials": {
        "telegramApi": {
          "id": "X4qyKQtMSdDRIqOu",
          "name": "Agent After Bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * Build Telegram Response ‚Äî alignment.clarify v1.0\n * - Resume evaluaci√≥n de Alignment\n * - Pide respuestas a power_questions\n * - Indica: responder + /continue para re-evaluar hasta >=80\n *\n * Input:  $json.output (Post-Merge envelope)\n * Output: $json.output.telegram.send_text + chat_id\n */\n\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\nfunction pick(arr, n){ return Array.isArray(arr) ? arr.slice(0, n) : []; }\n\nconst inItems = $input.all();\nconst out = [];\n\nfor (const it of inItems) {\n  const root = isObj(it.json) ? it.json : {};\n  const o = isObj(root.output) ? root.output : {};\n  const a = isObj(o.alignment) ? o.alignment : {};\n\n  const chat_id = o.chat_id;\n  const title = normStr(a._user_text || o._user_text || \"Idea\");\n  const score = (typeof a.score_total === \"number\") ? a.score_total : null;\n\n  const kpis = pick(a.recommended_kpis || [], 3).map(x => `‚Ä¢ ${normStr(x)}`).filter(Boolean).join(\"\\n\");\n  const deps = pick(a.key_dependencies || [], 2).map(x => `‚Ä¢ ${normStr(x)}`).filter(Boolean).join(\"\\n\");\n\n  const qs = pick(a.power_questions || [], 6).map((q, i) => `Q${i+1}. ${normStr(q)}`).filter(Boolean).join(\"\\n\");\n\n  const msg =\n`üß≠ Alignment Engine ‚Äî Clarify\n\nüìå Idea: ${title}\nüìä Score: ${score !== null ? score : \"N/A\"} / 100\n‚úÖ Va bien, pero a√∫n no pasa a AFTER. Necesitamos subir a 80+.\n\nüîç Lo m√°s fuerte (para sostener el caso)\n${kpis ? kpis : \"‚Ä¢ (pendiente definir KPIs con precisi√≥n)\"}\n\nüß© Dependencias clave (para no fallar en ejecuci√≥n)\n${deps ? deps : \"‚Ä¢ (pendiente confirmar dependencias t√©cnicas y operativas)\"}\n\nüß® Preguntas retadoras (resp√≥ndelas y re-evaluamos)\n${qs ? qs : \"Q1. (pendiente) Falta informaci√≥n m√≠nima para evaluar.\"}\n\nüìù Responde en este formato (corto y directo):\nA1: ...\nA2: ...\nA3: ...\nA4: ...\n(Si hay A5/A6, igual)\n\n‚úÖ Luego escribe /continue\nCon tus respuestas vuelvo a puntuar esta misma idea. Si pasa 80+, te habilito el salto a AFTER; si no, seguimos refinando ac√°.`;\n\n  if (!isObj(o.telegram)) o.telegram = {};\n  o.telegram.chat_id = chat_id;\n  o.telegram.send_text = msg;\n\n  root.output = o;\n  out.push({ json: root });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        1344
      ],
      "id": "ab0985d7-62e7-4ae0-842d-d2d92eeb69e8",
      "name": "Build Telegram Response alignment.clarify"
    },
    {
      "parameters": {
        "chatId": "={{ $json.output.telegram.chat_id }}",
        "text": "={{ $json.output.telegram.send_text }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        -16,
        1344
      ],
      "id": "4c405a01-8a9d-4918-a199-317d8d32e145",
      "name": "alignment.clarify",
      "webhookId": "ad341579-20e1-4502-a663-98e9ed0385ba",
      "credentials": {
        "telegramApi": {
          "id": "X4qyKQtMSdDRIqOu",
          "name": "Agent After Bot"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $json.chat_id }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        192,
        1184
      ],
      "id": "bbc638d3-141e-4145-81d9-1527de71ff4d",
      "name": "alignment.after_refine",
      "webhookId": "ad341579-20e1-4502-a663-98e9ed0385ba",
      "credentials": {
        "telegramApi": {
          "id": "X4qyKQtMSdDRIqOu",
          "name": "Agent After Bot"
        }
      }
    },
    {
      "parameters": {
        "chatId": "={{ $json.chat_id }}",
        "text": "={{ $json.text }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        192,
        1744
      ],
      "id": "cdf05dc6-ade1-4b21-8859-8449148a8b05",
      "name": "after.after_refinement",
      "webhookId": "ad341579-20e1-4502-a663-98e9ed0385ba",
      "credentials": {
        "telegramApi": {
          "id": "X4qyKQtMSdDRIqOu",
          "name": "Agent After Bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * Build Telegram Response ‚Äî after.after_brief v1.2 (AFTER v2.x + compat legacy)\n * - Lee AFTER v2.x desde output.after_result\n * - Usa output.brief.objectives si existe (nuevo)\n * - Fallback de objetivos: recommended_kpis o sprint_plan[0].goals (sin inventar)\n * - Sin \"No informado\" en Objetivos\n */\n\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\nfunction pick(arr, n){ return Array.isArray(arr) ? arr.slice(0, n) : []; }\n\nfunction bullets(arr, max=6){\n  const xs = pick(arr || [], max).map(x => `‚Ä¢ ${normStr(x)}`).filter(Boolean);\n  return xs.length ? xs.join(\"\\n\") : \"\";\n}\n\nfunction sprintCompactLines(sprintPlan){\n  const xs = pick(sprintPlan || [], 6).map(sp => {\n    if (!isObj(sp)) return \"\";\n    const spName = (typeof sp.sprint === \"number\") ? `Sprint ${sp.sprint}` : normStr(sp.sprint || \"Sprint\");\n    const goals = Array.isArray(sp.goals) ? sp.goals.map(normStr).filter(Boolean) : [normStr(sp.goals || \"\")].filter(Boolean);\n    const delivs = Array.isArray(sp.deliverables) ? sp.deliverables.map(normStr).filter(Boolean) : [];\n    const g0 = goals[0] || \"\";\n    const d0 = delivs[0] || \"\";\n    const tail = d0 ? ` ‚Äî ${d0}` : \"\";\n    return `‚Ä¢ ${spName}: ${g0}${tail}`.trim();\n  }).filter(Boolean);\n\n  return xs.length ? xs.join(\"\\n\") : \"\";\n}\n\nfunction storyLines(stories, max=10){\n  const xs = pick(stories || [], max).map(us => {\n    if (!isObj(us)) return \"\";\n    const id = normStr(us.id || \"\");\n    const title = normStr(us.title || \"\");\n    const size = normStr(us.size || \"\");\n    const hr = isObj(us.hours_range) ? us.hours_range : null;\n    const hmin = hr && typeof hr.min === \"number\" ? hr.min : null;\n    const hmax = hr && typeof hr.max === \"number\" ? hr.max : null;\n    const hrsTxt = (hmin !== null && hmax !== null) ? `${hmin}-${hmax}h` : \"\";\n    const prefix = [id, size, hrsTxt].filter(Boolean).join(\" \");\n    return `‚Ä¢ ${prefix} ‚Äî ${title}`.trim();\n  }).filter(Boolean);\n\n  return xs.length ? xs.join(\"\\n\") : \"\";\n}\n\nfunction calcTotalHoursRangeFromStories(stories){\n  let min = 0, max = 0, ok = false;\n  if (!Array.isArray(stories)) return null;\n  for (const us of stories){\n    if (!isObj(us) || !isObj(us.hours_range)) continue;\n    const a = us.hours_range.min, b = us.hours_range.max;\n    if (typeof a === \"number\" && typeof b === \"number\"){\n      min += a; max += b; ok = true;\n    }\n  }\n  return ok ? { min, max } : null;\n}\n\nfunction deriveObjectives(oBrief, ar){\n  const fromBrief = isObj(oBrief) && Array.isArray(oBrief.objectives) ? oBrief.objectives.map(normStr).filter(Boolean) : [];\n  if (fromBrief.length >= 3) return fromBrief.slice(0, 6);\n\n  const kpis = Array.isArray(ar.recommended_kpis) ? ar.recommended_kpis.map(normStr).filter(Boolean) : [];\n  if (kpis.length >= 3){\n    // Convertimos KPI -> objetivo operativo sin inventar: ‚ÄúAsegurar <KPI>‚Äù\n    return kpis.slice(0, 6).map(k => `Asegurar ${k}`);\n  }\n\n  const sp0 = Array.isArray(ar.sprint_plan) ? ar.sprint_plan[0] : null;\n  const goals = isObj(sp0) && Array.isArray(sp0.goals) ? sp0.goals.map(normStr).filter(Boolean) : [];\n  if (goals.length >= 3) return goals.slice(0, 6).map(g => `Ejecutar ${g}`);\n\n  // √∫ltimo fallback sin ‚ÄúNo informado‚Äù: 3 objetivos gen√©ricos alineados a OPT (sin n√∫meros)\n  return [\n    \"Aumentar ingresos por cobranza sin degradar continuidad operativa.\",\n    \"Reducir fricci√≥n y tiempos de gesti√≥n en el flujo E2E de mora.\",\n    \"Asegurar auditor√≠a, reversa y control de disputas con trazabilidad.\"\n  ];\n}\n\nconst inItems = $input.all();\nconst out = [];\n\nfor (const it of inItems) {\n  const root = isObj(it.json) ? it.json : {};\n  const o = isObj(root.output) ? root.output : {};\n\n  const chat_id = normStr(o.chat_id || \"\");\n  if (!chat_id) throw new Error(\"after.after_brief: falta output.chat_id\");\n\n  const ar = isObj(o.after_result) ? o.after_result : {};\n  const legacyBrief = isObj(o.brief) ? o.brief : {};\n\n  const isAfterV2 = !!normStr(ar.executive_summary || ar.feature_title || \"\");\n\n  const ready = isAfterV2 ? !!ar.brief_ready : false;\n\n  const feature = normStr(\n    (isAfterV2 ? ar.feature_title : \"\") ||\n    o._user_text ||\n    o.idea_text ||\n    \"Feature\"\n  );\n\n  const summary = normStr((isAfterV2 ? ar.executive_summary : \"\") || \"\");\n\n  const puntos = isAfterV2 ? (Array.isArray(ar.checkpoints_obligatorios) ? ar.checkpoints_obligatorios : []) : [];\n\n  const risks = isAfterV2 ? (Array.isArray(ar.key_risks) ? ar.key_risks : []) : [];\n  const deps  = isAfterV2 ? (Array.isArray(ar.key_dependencies) ? ar.key_dependencies : []) : [];\n\n  const roadmapTxt = isAfterV2 ? sprintCompactLines(ar.sprint_plan || []) : \"\";\n\n  let pilotTxt = \"\";\n  if (isAfterV2){\n    const sp0 = Array.isArray(ar.sprint_plan) ? ar.sprint_plan[0] : null;\n    if (isObj(sp0) && Array.isArray(sp0.deliverables) && sp0.deliverables.length){\n      pilotTxt = bullets(sp0.deliverables, 4);\n    }\n  }\n\n  let totalRange = isObj(ar.macro_estimation_hours_total_range) ? ar.macro_estimation_hours_total_range : null;\n  if (!totalRange && Array.isArray(ar.user_stories)){\n    totalRange = calcTotalHoursRangeFromStories(ar.user_stories);\n  }\n\n  const huTxt = isAfterV2 ? storyLines(ar.user_stories || [], 10) : \"\";\n\n  const execSum = normStr(ar.executive_summary || \"\");\n\n  const objectivesArr = deriveObjectives(legacyBrief, ar);\n  const objectivesTxt = bullets(objectivesArr, 6);\n\n  const keyResults = Array.isArray(ar.recommended_kpis) ? ar.recommended_kpis : [];\n\n  const qLines = Array.isArray(ar.questions) && ar.questions.length\n    ? pick(ar.questions, 8).map((q, i) => `A${i+1}: ${normStr(q)}`).filter(Boolean).join(\"\\n\")\n    : \"\";\n\n  const nextInstr = normStr(ar.next_user_instruction || \"\");\n\n  const msg =\n`‚úÖ AFTER ‚Äî Brief listo (READY=${ready ? \"SI\" : \"NO\"})\n\nüìå Feature: ${feature}\n\nüß† Resumen\n${summary}\n\nüß≠ Puntos de control obligatorios (condici√≥n m√≠nima con evidencia para avanzar)\n${bullets(puntos, 6)}\n\nüß™ Piloto pr√°ctico (SP01/SP00)\n${pilotTxt}\n\nüó∫Ô∏è Roadmap (captura de valor por sprint)\n${roadmapTxt}\n\nüßæ Macro-estimaci√≥n (HUs + horas)\n${(totalRange && typeof totalRange.min === \"number\" && typeof totalRange.max === \"number\") ? `Total: ${totalRange.min}-${totalRange.max}h` : \"Total:  No calculable\"}\n${huTxt}\n\nüìÑ Brief ejecutivo (resumen para direcci√≥n)\nüßæ Executive summary\n${execSum}\n\nüéØ Objetivos\n${objectivesTxt}\n\nüèÅ Resultados esperados\n${bullets(keyResults, 6)}\n\n‚ö†Ô∏è Riesgos\n${bullets(risks, 6)}\n\nüîó Dependencias\n${bullets(deps, 6)}\n\n${qLines ? `‚ùì Resp√≥ndeme esto (corto y directo)\\n${qLines}\\n` : \"\"}üëâ Siguiente paso\n${nextInstr}`;\n\n  if (!isObj(o.telegram)) o.telegram = {};\n  o.telegram.chat_id = chat_id;\n  o.telegram.send_text = msg;\n\n  root.output = o;\n  out.push({ json: root });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        2224
      ],
      "id": "ca780b9a-a21e-43b8-8e7e-c5edb88d64e9",
      "name": "Build Telegram Response ‚Äî after.after_brief"
    },
    {
      "parameters": {
        "chatId": "={{ $json.output.telegram.chat_id }}",
        "text": "={{ $json.output.telegram.send_text }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        0,
        2224
      ],
      "id": "558fba01-d254-4fe8-a92f-0fba0549de7e",
      "name": "after.after_brief",
      "webhookId": "ad341579-20e1-4502-a663-98e9ed0385ba",
      "credentials": {
        "telegramApi": {
          "id": "X4qyKQtMSdDRIqOu",
          "name": "Agent After Bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node ‚Äî Build HTML Brief Ejecutivo (SendGrid) ¬∑ v1.0\n * Input:  item.json.output (envelope AFTER) o item.json (si ya viene plano)\n * Output: mantiene output y agrega:\n *   - output.subject\n *   - output.html_email  (version email-safe)\n *   - output.html_full   (igual al email, pero lo dejamos separado por si luego quieres ‚Äúfull‚Äù)\n *   - output.quarter_target\n *\n * Dise√±o: ejecutivo, ‚Äúultra pro‚Äù, inline CSS (SendGrid-safe).\n */\n\nfunction coalesce(...args){ for (const v of args) if (v !== undefined && v !== null && v !== \"\") return v; return null; }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\n\nfunction esc(s=\"\"){\n  return String(s)\n    .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')\n    .replace(/\"/g,'&quot;').replace(/'/g,'&#39;');\n}\n\nfunction safeArr(a){\n  return Array.isArray(a) ? a.filter(Boolean).map(x => normStr(x)).filter(Boolean) : [];\n}\n\nfunction nowISO(){\n  return new Date().toISOString();\n}\n\n// Quarter label like \"1Q 2026\"\nfunction quarterTarget(date = new Date()){\n  const y = date.getFullYear();\n  const m = date.getMonth() + 1; // 1..12\n  const q = Math.floor((m - 1) / 3) + 1;\n  return `${q}Q ${y}`;\n}\n\nfunction pill(text, bg, fg){\n  return `<span style=\"display:inline-block;padding:5px 10px;border-radius:999px;background:${bg};color:${fg};font-size:12px;font-weight:700;line-height:1\">${esc(text)}</span>`;\n}\n\nfunction sectionTitle(txt){\n  return `<div style=\"font-size:14px;font-weight:900;color:#0b1f3a;margin:0 0 10px 0\">${esc(txt)}</div>`;\n}\n\nfunction ul(items){\n  const arr = safeArr(items);\n  if (!arr.length) return `<div style=\"font-size:13px;color:#667085\">‚Äî</div>`;\n  return `<ul style=\"margin:0;padding-left:18px\">${arr.map(x => `<li style=\"margin:6px 0;color:#1c2b3a;line-height:1.45\">${esc(x)}</li>`).join(\"\")}</ul>`;\n}\n\nfunction tableKpis(kpis){\n  const arr = safeArr(kpis);\n  const rows = arr.map(k => {\n    // try to split \"X. Target: Y\" format\n    let name = k, target = \"\", meta = \"\";\n    const parts = k.split(\"Target:\");\n    if (parts.length > 1){\n      name = parts[0].trim().replace(/\\.\\s*$/,\"\");\n      target = parts.slice(1).join(\"Target:\").trim();\n    } else {\n      // Try \" - \" or \" ‚Äî \"\n      const m = k.split(\"‚Äî\");\n      if (m.length > 1){\n        name = m[0].trim();\n        meta = m.slice(1).join(\"‚Äî\").trim();\n      }\n    }\n    return `\n      <tr>\n        <td style=\"vertical-align:top;padding:10px;border-bottom:1px solid #f0f2f6;color:#1c2b3a;font-size:12px;font-weight:800\">${esc(name)}</td>\n        <td style=\"vertical-align:top;padding:10px;border-bottom:1px solid #f0f2f6;color:#1c2b3a;font-size:12px\">${esc(target || meta || \"Definir umbral operativo (baseline + target) en ventana piloto.\")}</td>\n        <td style=\"vertical-align:top;padding:10px;border-bottom:1px solid #f0f2f6;color:#667085;font-size:12px\">Semanal (piloto) ¬∑ Mensual (rollout)</td>\n      </tr>\n    `;\n  }).join(\"\");\n\n  return `\n    <table width=\"100%\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse;border:1px solid #e6e9ef;border-radius:14px;overflow:hidden\">\n      <thead>\n        <tr style=\"background:#f7f9fc\">\n          <th style=\"text-align:left;padding:10px;border-bottom:1px solid #e6e9ef;color:#0b1f3a;font-size:12px\">KPI</th>\n          <th style=\"text-align:left;padding:10px;border-bottom:1px solid #e6e9ef;color:#0b1f3a;font-size:12px\">Umbral / Target</th>\n          <th style=\"text-align:left;padding:10px;border-bottom:1px solid #e6e9ef;color:#0b1f3a;font-size:12px\">Frecuencia</th>\n        </tr>\n      </thead>\n      <tbody>\n        ${rows || `<tr><td colspan=\"3\" style=\"padding:10px;color:#667085;font-size:12px\">KPIs operables se derivan del caso; validar baseline + target.</td></tr>`}\n      </tbody>\n    </table>\n  `;\n}\n\nfunction roadmapTable(sprints){\n  const arr = Array.isArray(sprints) ? sprints : [];\n  const rows = arr.map(sp => {\n    const sprint = normStr(sp?.sprint || \"\");\n    const goals = safeArr(sp?.goals).slice(0,6);\n    const dels  = safeArr(sp?.deliverables).slice(0,8);\n    return `\n      <tr>\n        <td style=\"vertical-align:top;padding:10px;border-bottom:1px solid #f0f2f6;color:#1c2b3a;font-size:12px;font-weight:900\">${esc(sprint)}</td>\n        <td style=\"vertical-align:top;padding:10px;border-bottom:1px solid #f0f2f6;color:#1c2b3a;font-size:12px\">${ul(goals).replace('<ul','<ul style=\"margin:0;padding-left:16px\"').replace('style=\"margin:0;padding-left:18px\"','style=\"margin:0;padding-left:16px\"')}</td>\n        <td style=\"vertical-align:top;padding:10px;border-bottom:1px solid #f0f2f6;color:#1c2b3a;font-size:12px\">${ul(dels).replace('<ul','<ul style=\"margin:0;padding-left:16px\"').replace('style=\"margin:0;padding-left:18px\"','style=\"margin:0;padding-left:16px\"')}</td>\n      </tr>\n    `;\n  }).join(\"\");\n\n  return `\n    <table width=\"100%\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse;border:1px solid #e6e9ef;border-radius:14px;overflow:hidden\">\n      <thead>\n        <tr style=\"background:#f7f9fc\">\n          <th style=\"text-align:left;padding:10px;border-bottom:1px solid #e6e9ef;color:#0b1f3a;font-size:12px\">Sprint</th>\n          <th style=\"text-align:left;padding:10px;border-bottom:1px solid #e6e9ef;color:#0b1f3a;font-size:12px\">Foco</th>\n          <th style=\"text-align:left;padding:10px;border-bottom:1px solid #e6e9ef;color:#0b1f3a;font-size:12px\">Entregables medibles</th>\n        </tr>\n      </thead>\n      <tbody>${rows || \"\"}</tbody>\n    </table>\n  `;\n}\n\nfunction storiesTable(stories){\n  const arr = Array.isArray(stories) ? stories : [];\n  // Mantener ‚Äúexecutive‚Äù: top 8 por orden\n  const top = arr.slice(0, 8);\n\n  const rows = top.map(us => {\n    const id = normStr(us?.id || \"\");\n    const title = normStr(us?.title || \"\");\n    const hrMin = us?.hours_range?.min;\n    const hrMax = us?.hours_range?.max;\n    const hours = (Number.isFinite(hrMin) && Number.isFinite(hrMax)) ? `${hrMin}-${hrMax}h` : \"‚Äî\";\n    const deps = \"\"; // deps por historia no vienen; mantenemos limpio\n    const ac = safeArr(us?.acceptance).slice(0,2).join(\" | \");\n    return `\n      <tr>\n        <td style=\"vertical-align:top;padding:10px;border-bottom:1px solid #f0f2f6;color:#1c2b3a;font-size:12px;font-weight:900\">${esc(id)}</td>\n        <td style=\"vertical-align:top;padding:10px;border-bottom:1px solid #f0f2f6;color:#1c2b3a;font-size:12px;font-weight:800\">${esc(title)}</td>\n        <td style=\"vertical-align:top;padding:10px;border-bottom:1px solid #f0f2f6;color:#1c2b3a;font-size:12px\">${esc(hours)}</td>\n        <td style=\"vertical-align:top;padding:10px;border-bottom:1px solid #f0f2f6;color:#667085;font-size:12px\">${esc(ac || \"Criterios de aceptaci√≥n definidos en el brief t√©cnico.\")}</td>\n      </tr>\n    `;\n  }).join(\"\");\n\n  return `\n    <table width=\"100%\" cellpadding=\"0\" cellspacing=\"0\" style=\"border-collapse:collapse;border:1px solid #e6e9ef;border-radius:14px;overflow:hidden\">\n      <thead>\n        <tr style=\"background:#f7f9fc\">\n          <th style=\"text-align:left;padding:10px;border-bottom:1px solid #e6e9ef;color:#0b1f3a;font-size:12px\">HU</th>\n          <th style=\"text-align:left;padding:10px;border-bottom:1px solid #e6e9ef;color:#0b1f3a;font-size:12px\">T√≠tulo</th>\n          <th style=\"text-align:left;padding:10px;border-bottom:1px solid #e6e9ef;color:#0b1f3a;font-size:12px\">Horas</th>\n          <th style=\"text-align:left;padding:10px;border-bottom:1px solid #e6e9ef;color:#0b1f3a;font-size:12px\">Criterio de aceptaci√≥n (top)</th>\n        </tr>\n      </thead>\n      <tbody>${rows || \"\"}</tbody>\n    </table>\n  `;\n}\n\nfunction computeObjectives(o){\n  // 1) Si vienen expl√≠citos, usarlo\n  const explicit =\n    safeArr(o?.brief?.objectives)\n      .concat(safeArr(o?.after_result?.brief?.objectives))\n      .concat(safeArr(o?.after_result?.objectives))\n      .filter(Boolean);\n\n  if (explicit.length) return explicit.slice(0, 6);\n\n  // 2) Derivar de KPIs (convertir a ‚ÄúObjetivos‚Äù)\n  const kpis = safeArr(o?.after_result?.recommended_kpis);\n  const derived = [];\n  for (const k of kpis){\n    const base = k.replace(/Target:\\s*/i, \"Meta: \").trim();\n    derived.push(base);\n  }\n\n  // 3) Completar con 1-2 objetivos ‚Äúestructurales‚Äù basados en el caso\n  const sum = normStr(o?.after_result?.executive_summary || \"\");\n  if (/cobro|cobranza|mora/i.test(sum)){\n    derived.push(\"Reducir fricci√≥n y tiempos de cobranza, manteniendo cumplimiento, trazabilidad y control de disputas.\");\n    derived.push(\"Proteger BAU y reputaci√≥n con guardrails, auditor√≠a y rollback para decisiones automatizadas.\");\n  } else {\n    derived.push(\"Asegurar implementaci√≥n E2E: datos ‚Üí decisi√≥n ‚Üí operaci√≥n ‚Üí auditor√≠a, con evidencia reproducible.\");\n    derived.push(\"Proteger BAU (performance/continuidad) con controles, monitoreo y contingencias autom√°ticas.\");\n  }\n\n  // No vac√≠os: m√≠nimo 2\n  return derived.filter(Boolean).slice(0, 6);\n}\n\nfunction buildHTML(o){\n  const ar = o.after_result || {};\n  const qt = o.quarter_target || quarterTarget(new Date());\n\n  const feature = normStr(ar.feature_title || o.feature_title || \"Brief Ejecutivo\");\n  const summary = normStr(ar.executive_summary || ar.summary || \"Resumen ejecutivo no disponible.\");\n  const objectives = computeObjectives(o);\n\n  const kpis = safeArr(ar.recommended_kpis);\n  const deps = safeArr(ar.key_dependencies);\n  const risks = safeArr(ar.key_risks);\n  const ready = safeArr(ar.readiness_criteria_min);\n  const checkpoints = safeArr(ar.checkpoints_obligatorios);\n  const sprints = Array.isArray(ar.sprint_plan) ? ar.sprint_plan : [];\n  const stories = Array.isArray(ar.user_stories) ? ar.user_stories : [];\n\n  const hrsMin = ar?.macro_estimation_hours_total_range?.min;\n  const hrsMax = ar?.macro_estimation_hours_total_range?.max;\n  const hoursLabel = (Number.isFinite(hrsMin) && Number.isFinite(hrsMax)) ? `${hrsMin}‚Äì${hrsMax}h` : \"Rango calculado por HUs\";\n\n  // Piloto: preferimos SP01\n  const sp01 = sprints.find(x => normStr(x?.sprint) === \"SP01\") || sprints[1] || null;\n  const pilotText = sp01\n    ? `Piloto pr√°ctico en ${esc(normStr(sp01.sprint))}: ${ul(safeArr(sp01.deliverables).slice(0,4)).replace('<ul','<ul style=\"margin:0;padding-left:18px\"')}`\n    : `Piloto pr√°ctico: ejecutar un MVP medible con criterios de √©xito (KPIs vs baseline) y auditor√≠a operacional.`;\n\n  const genAt = nowISO();\n\n  // ‚ÄúUltra pro‚Äù email-safe\n  return `<!doctype html>\n<html>\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>Brief Ejecutivo</title>\n</head>\n<body style=\"margin:0;background:#f5f7fb;font-family:Inter,Arial,sans-serif;color:#101828\">\n  <div style=\"max-width:980px;margin:0 auto;padding:28px\">\n    <!-- Header -->\n    <div style=\"background:linear-gradient(135deg,#00A9E0,#003245);border-radius:18px;padding:22px 22px 18px 22px;color:white;\">\n      <div style=\"font-size:12px;opacity:.92;letter-spacing:.2px\">AFTER ¬∑ Brief Ejecutivo ¬∑ ${esc(qt)}</div>\n      <div style=\"font-size:24px;font-weight:900;margin-top:6px;line-height:1.15\">${esc(feature)}</div>\n      <div style=\"margin-top:10px;font-size:13px;opacity:.95;line-height:1.5\">${esc(summary)}</div>\n      <div style=\"margin-top:12px\">\n        ${pill(\"Decisi√≥n basada en evidencia\", \"#F2F4F7\", \"#344054\")}\n        &nbsp; ${pill(\"Operable para BRP\", \"#F2F4F7\", \"#344054\")}\n        &nbsp; ${pill(`Quarter: ${qt}`, \"#E8F4FF\", \"#0B4F8A\")}\n        &nbsp; ${pill(`Macro: ${hoursLabel}`, \"#E8FFF3\", \"#027A48\")}\n      </div>\n    </div>\n\n    <!-- Grid -->\n    <div style=\"display:grid;grid-template-columns:1.2fr .8fr;gap:16px;margin-top:16px\">\n\n      <!-- Left: Core -->\n      <div style=\"background:white;border:1px solid #e6e9ef;border-radius:18px;padding:18px\">\n        ${sectionTitle(\"Resumen ejecutivo\")}\n        <div style=\"font-size:13px;color:#1c2b3a;line-height:1.55\">${esc(summary)}</div>\n\n        <div style=\"height:14px\"></div>\n        ${sectionTitle(\"Objetivos\")}\n        ${ul(objectives)}\n\n        <div style=\"height:14px\"></div>\n        ${sectionTitle(\"KPIs y criterio de √©xito\")}\n        <div style=\"font-size:12px;color:#667085;margin:0 0 10px 0\">\n          Targets operables para piloto (baseline vs post), con frecuencia y evidencia reproducible.\n        </div>\n        ${tableKpis(kpis)}\n        <div style=\"margin-top:10px;font-size:12px;color:#667085;line-height:1.4\">\n          <b>Criterio de √©xito:</b> mejora estad√≠sticamente v√°lida vs baseline en el piloto (SP01), sin degradar BAU, con auditor√≠a y trazabilidad de decisiones.\n        </div>\n\n        <div style=\"height:14px\"></div>\n        ${sectionTitle(\"Puntos de control obligatorios\")}\n        ${ul(checkpoints)}\n\n        <div style=\"height:14px\"></div>\n        ${sectionTitle(\"READY m√≠nimo (condici√≥n de arranque)\")}\n        ${ul(ready)}\n\n        <div style=\"height:14px\"></div>\n        ${sectionTitle(\"Piloto pr√°ctico\")}\n        <div style=\"font-size:13px;color:#1c2b3a;line-height:1.55\">${pilotText}</div>\n      </div>\n\n      <!-- Right: Exec guidance + risks/deps -->\n      <div>\n        <!-- Director Profile OPT E2E (compact) -->\n        <div style=\"border:1px solid #e6e9ef;border-radius:14px;padding:14px;background:#ffffff\">\n          <div style=\"font-size:12px;color:#667085;margin-bottom:6px\">Gu√≠a estrat√©gica (Direcci√≥n OPT E2E)</div>\n          <div style=\"font-size:12px;color:#1c2b3a;line-height:1.5\">\n            <b>Enfoque:</b> caja/FCF + eficiencia OPEX, ejecuci√≥n E2E, IA con control (auditor√≠a, reversa, trazabilidad) y BAU protegido.\n          </div>\n          <div style=\"font-size:12px;color:#1c2b3a;line-height:1.5;margin-top:6px\">\n            <b>Regla de decisi√≥n:</b> umbrales KPI + dependencia #1 confirmada + piloto medible + guardrails/kill-switch antes de escalar.\n          </div>\n        </div>\n\n        <div style=\"margin-top:16px;background:white;border:1px solid #e6e9ef;border-radius:18px;padding:18px\">\n          ${sectionTitle(\"Dependencias cr√≠ticas\")}\n          ${ul(deps)}\n        </div>\n\n        <div style=\"margin-top:16px;background:white;border:1px solid #e6e9ef;border-radius:18px;padding:18px\">\n          ${sectionTitle(\"Riesgos y controles\")}\n          ${ul(risks)}\n          <div style=\"margin-top:10px;font-size:12px;color:#667085;line-height:1.4\">\n            <b>Control m√≠nimo:</b> kill-switch + rollback + muestreo/auditor√≠a de decisiones + trazabilidad de datos/modelo.\n          </div>\n        </div>\n      </div>\n\n    </div>\n\n    <!-- Roadmap -->\n    <div style=\"background:white;border:1px solid #e6e9ef;border-radius:18px;padding:18px;margin-top:16px\">\n      ${sectionTitle(\"Roadmap del trimestre (sprints)\")}\n      <div style=\"font-size:12px;color:#667085;margin:0 0 10px 0\">Entrega incremental con evidencia por sprint (demo-first).</div>\n      ${roadmapTable(sprints)}\n    </div>\n\n    <!-- Macro HUs -->\n    <div style=\"background:white;border:1px solid #e6e9ef;border-radius:18px;padding:18px;margin-top:16px\">\n      ${sectionTitle(\"Macro HUs (macroestimaci√≥n)\")}\n      <div style=\"font-size:12px;color:#667085;margin:0 0 10px 0\">Top HUs con rango de horas y criterios de aceptaci√≥n.</div>\n      ${storiesTable(stories)}\n      <div style=\"margin-top:10px;font-size:12px;color:#667085\">\n        <b>Nota:</b> si alguna HU supera 40h, dividir para control de riesgo, trazabilidad y entrega incremental.\n      </div>\n    </div>\n\n    <!-- Footer -->\n    <div style=\"margin-top:16px;text-align:center;color:#98a2b3;font-size:11px\">\n      Generado por AfterBot ¬∑ Brief Ejecutivo ¬∑ ${esc(genAt)}\n    </div>\n  </div>\n</body>\n</html>`;\n}\n\nconst out = [];\nconst inItems = Array.isArray(items) ? items : $input.all();\n\nfor (const it of inItems){\n  const j = isObj(it.json) ? it.json : {};\n  const o = isObj(j.output) ? j.output : j;\n\n  // Defensive: keep original envelope shape\n  if (!isObj(o.after_result)) o.after_result = {};\n\n  // Derive quarter target if missing\n  o.quarter_target = normStr(coalesce(o.quarter_target, quarterTarget(new Date())));\n\n  const feature = normStr(coalesce(o.after_result?.feature_title, o.feature_title, \"Brief Ejecutivo\"));\n  // Subject: crisp, director-friendly\n  o.subject = `Brief Ejecutivo ¬∑ ${feature} ¬∑ ${o.quarter_target}`;\n\n  const html = buildHTML(o);\n  o.html_email = html;\n  o.html_full = html;\n\n  out.push({ json: { output: o } });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        2416
      ],
      "id": "abd3a2ca-dbf3-4c22-a890-e316c05be42d",
      "name": "Build HTML Brief Ejecutivo"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code node ‚Äî SendGrid Email (AFTER Brief) v2.6 (FIX)\n * FIX:\n * - Evita fallo por respuesta 202 sin JSON => json:false\n * - resolveWithFullResponse:true para ver statusCode\n * - Body HTML m√°s ejecutivo (cover) + adjunto HTML\n */\n\nconst SENDGRID_API_KEY = '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'; // deja tu key quemada en tu n8n\nconst FROM_EMAIL = 'agenteafter@telefonica.com.co';\nconst FROM_NAME  = 'IA PARA TODOS ¬∑ Agente AFTER';\nconst ALWAYS_CC  = 'misaac.torres@telefonica.com';\n\nconst EMAIL_RE = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$/;\n\nfunction esc(s=''){\n  return String(s)\n    .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')\n    .replace(/\"/g,'&quot;').replace(/'/g,'&#39;');\n}\nfunction extractEmailFromText(text=''){\n  const m = String(text).match(/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}/);\n  return m ? m[0] : '';\n}\nfunction coalesce(...args){ for (const v of args) if (v !== undefined && v !== null && v !== \"\") return v; return null; }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\n\nfunction findUserEmail(j){\n  if (j.user_email && EMAIL_RE.test(j.user_email)) return j.user_email;\n  if (j.output && j.output.user_email && EMAIL_RE.test(j.output.user_email)) return j.output.user_email;\n  const t = coalesce(j._user_text, j.output?._user_text, \"\");\n  const e = extractEmailFromText(t);\n  if (EMAIL_RE.test(e)) return e;\n  return '';\n}\n\nfunction quarterTarget(d=new Date()){\n  const y = d.getFullYear();\n  const m = d.getMonth() + 1;\n  const q = Math.floor((m - 1) / 3) + 1;\n  return `${q}Q ${y}`;\n}\n\nfunction pickFirst(arr, n=3){\n  return Array.isArray(arr) ? arr.filter(Boolean).slice(0,n) : [];\n}\n\nfunction buildExecutiveCover(meta){\n  const feature = esc(meta.feature_title || \"Brief Ejecutivo\");\n  const qt = esc(meta.quarter_target || quarterTarget());\n  const macro = esc(meta.macro_range || \"rango estimado seg√∫n HUs\");\n  const summary = esc(meta.executive_summary || \"\");\n  const readyBadge = meta.brief_ready ? \"READY: S√ç\" : \"READY: NO\";\n\n  const kpis = pickFirst(meta.kpis, 3);\n  const deps = pickFirst(meta.dependencies, 3);\n  const risks = pickFirst(meta.risks, 3);\n\n  const miniList = (arr) =>\n    arr.length\n      ? arr.map(x => `<div style=\"margin:0 0 6px 0;color:#1D2939;font-size:12px;line-height:1.4;\">‚Ä¢ ${esc(String(x))}</div>`).join('')\n      : `<div style=\"color:#667085;font-size:12px;\">Ver detalle en el brief.</div>`;\n\n  const kpiCards = kpis.length\n    ? kpis.map((k,i)=>`\n      <div style=\"border:1px solid #EAECF0;border-radius:14px;background:#FFFFFF;padding:10px 12px;margin-bottom:10px;\">\n        <div style=\"font-size:11px;color:#667085;font-weight:900;letter-spacing:.2px;\">KPI ${i+1}</div>\n        <div style=\"font-size:13px;color:#101828;font-weight:1000;line-height:1.35;\">${esc(String(k))}</div>\n      </div>\n    `).join('')\n    : `<div style=\"border:1px solid #EAECF0;border-radius:14px;background:#FFFFFF;padding:10px 12px;\">\n         <div style=\"font-size:11px;color:#667085;font-weight:900;\">KPIs</div>\n         <div style=\"font-size:13px;color:#101828;font-weight:1000;\">Ver KPIs en el brief adjunto</div>\n       </div>`;\n\n  return `\n  <table role=\"presentation\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\" style=\"margin:0;padding:0;background:#F2F4F7;\">\n    <tr>\n      <td align=\"center\" style=\"padding:22px 10px;\">\n        <table role=\"presentation\" width=\"980\" cellpadding=\"0\" cellspacing=\"0\" style=\"width:100%;max-width:980px;\">\n          <tr>\n            <td style=\"font-family:Arial,Helvetica,sans-serif;padding:0 0 12px 0;\">\n              <table role=\"presentation\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\">\n                <tr>\n                  <td>\n                    <div style=\"font-size:12px;color:#0B4F8A;font-weight:900;letter-spacing:.3px;\">IA PARA TODOS</div>\n                    <div style=\"font-size:22px;color:#101828;font-weight:1000;line-height:1.15;\">AFTER ¬∑ Brief Ejecutivo</div>\n                  </td>\n                  <td align=\"right\">\n                    <span style=\"display:inline-block;padding:8px 12px;border-radius:999px;background:#E8F4FF;color:#0B4F8A;font-size:12px;font-weight:900;\">${qt}</span>\n                    <span style=\"display:inline-block;padding:8px 12px;border-radius:999px;background:#E8FFF3;color:#027A48;font-size:12px;font-weight:900;margin-left:6px;\">${macro}</span>\n                    <span style=\"display:inline-block;padding:8px 12px;border-radius:999px;background:#FFFFFF;border:1px solid #EAECF0;color:#344054;font-size:12px;font-weight:1000;margin-left:6px;\">${readyBadge}</span>\n                  </td>\n                </tr>\n              </table>\n            </td>\n          </tr>\n\n          <tr>\n            <td style=\"background:#FFFFFF;border:1px solid #EAECF0;border-radius:18px;padding:18px;\">\n              <table role=\"presentation\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\">\n                <tr>\n                  <td valign=\"top\" style=\"width:58%;padding-right:14px;\">\n                    <div style=\"font-size:18px;font-weight:1000;color:#101828;line-height:1.2;\">${feature}</div>\n\n                    <div style=\"margin-top:10px;padding:12px 12px;border-radius:14px;background:#F8FAFC;border:1px solid #EAECF0;\">\n                      <div style=\"font-size:12px;font-weight:900;color:#344054;letter-spacing:.2px;\">Executive summary</div>\n                      <div style=\"margin-top:6px;font-size:12px;color:#1D2939;line-height:1.6;\">${summary}</div>\n                    </div>\n\n                    <div style=\"margin-top:12px;background:#003245;border-radius:14px;padding:14px 14px;color:#FFFFFF;\">\n                      <div style=\"font-size:12px;font-weight:900;letter-spacing:.2px;opacity:.95;\">ACCI√ìN REQUERIDA (2 minutos)</div>\n                      <div style=\"margin-top:6px;font-size:13px;line-height:1.55;\">\n                        1) Confirmar <b>GO/NO-GO</b> del piloto <b>SP01</b> con criterio de √©xito.<br/>\n                        2) Confirmar <b>owner + fecha</b> de la dependencia #1 y <b>guardrails</b> (kill-switch/rollback).\n                      </div>\n                      <div style=\"margin-top:10px;background:#00A9E0;border-radius:12px;padding:10px 12px;font-weight:1000;font-size:13px;text-align:center;\">\n                        Responder: ‚ÄúGO + owner + fecha‚Äù √≥ ‚ÄúNO-GO + ajuste requerido‚Äù\n                      </div>\n                    </div>\n\n                    <div style=\"margin-top:12px;padding:12px 12px;border-radius:14px;background:#F8FAFC;border:1px solid #EAECF0;\">\n                      <div style=\"font-size:11px;color:#667085;line-height:1.6;\">\n                        Incluimos el brief <b>en el cuerpo</b> y tambi√©n como adjunto (<b>after-brief-ejecutivo.html</b>) para m√°xima compatibilidad.\n                      </div>\n                    </div>\n                  </td>\n\n                  <td valign=\"top\" style=\"width:42%;padding-left:14px;\">\n                    <div style=\"font-size:12px;color:#344054;font-weight:1000;letter-spacing:.2px;margin-bottom:8px;\">Scorecard de negocio (KPIs)</div>\n                    ${kpiCards}\n\n                    <div style=\"margin-top:10px;padding:12px 12px;border-radius:14px;border:1px solid #EAECF0;background:#FFFFFF;\">\n                      <div style=\"font-size:12px;color:#344054;font-weight:1000;letter-spacing:.2px;margin-bottom:6px;\">Dependencias (top 3)</div>\n                      ${miniList(deps)}\n                    </div>\n\n                    <div style=\"margin-top:10px;padding:12px 12px;border-radius:14px;border:1px solid #EAECF0;background:#FFFFFF;\">\n                      <div style=\"font-size:12px;color:#344054;font-weight:1000;letter-spacing:.2px;margin-bottom:6px;\">Riesgos & controles (top 3)</div>\n                      ${miniList(risks)}\n                    </div>\n\n                    <div style=\"margin-top:10px;padding:12px 12px;border-radius:14px;border:1px solid #EAECF0;background:#F8FAFC;\">\n                      <div style=\"font-size:11px;color:#667085;line-height:1.6;\">\n                        <b>Garant√≠a de ejecuci√≥n:</b> piloto SP01 medible + trazabilidad + reversa + auditor√≠a. Sin eso, no hay escala.\n                      </div>\n                    </div>\n                  </td>\n                </tr>\n              </table>\n            </td>\n          </tr>\n\n        </table>\n      </td>\n    </tr>\n  </table>\n  `;\n}\n\nfunction injectCoverIntoHtml(existingHtml, coverHtml){\n  const html = String(existingHtml || \"\");\n  const bodyIdx = html.search(/<body[^>]*>/i);\n  if (bodyIdx >= 0){\n    const match = html.match(/<body[^>]*>/i);\n    const bodyTag = match ? match[0] : \"<body>\";\n    const insertPos = bodyIdx + bodyTag.length;\n    return html.slice(0, insertPos) + coverHtml + html.slice(insertPos);\n  }\n  return `<!doctype html><html><head><meta charset=\"utf-8\"></head><body style=\"margin:0;background:#F2F4F7;\">${coverHtml}${html}</body></html>`;\n}\n\n// -------- INPUT --------\nconst inItems = (typeof items !== \"undefined\" && Array.isArray(items)) ? items : $input.all();\nconst j = (inItems[0] && inItems[0].json) ? inItems[0].json : {};\nconst output = isObj(j.output) ? j.output : null;\nconst ar = output?.after_result || {};\n\nconst feature_title = normStr(coalesce(ar.feature_title, output?.feature_title, \"Brief Ejecutivo\"));\nconst executive_summary = normStr(coalesce(ar.executive_summary, output?.executive_summary, \"\"));\nconst qt = normStr(coalesce(output?.quarter_target, quarterTarget()));\nconst hrMin = ar?.macro_estimation_hours_total_range?.min;\nconst hrMax = ar?.macro_estimation_hours_total_range?.max;\nconst macro_range = (Number.isFinite(hrMin) && Number.isFinite(hrMax)) ? `${hrMin}‚Äì${hrMax}h` : \"rango estimado seg√∫n HUs\";\n\nconst subject = `IA PARA TODOS ¬∑ ${feature_title} ¬∑ ${qt}`;\n\n// HTML base (del nodo brief builder anterior)\nconst htmlEmailBase = coalesce(j.html_email, output?.html_email, '<!doctype html><html><body>Sin HTML.</body></html>');\nconst htmlFullBase  = coalesce(j.html_full, output?.html_full, htmlEmailBase);\n\nconst meta = {\n  feature_title,\n  quarter_target: qt,\n  macro_range,\n  executive_summary,\n  kpis: Array.isArray(ar.recommended_kpis) ? ar.recommended_kpis : [],\n  dependencies: Array.isArray(ar.key_dependencies) ? ar.key_dependencies : [],\n  risks: Array.isArray(ar.key_risks) ? ar.key_risks : [],\n  brief_ready: !!ar.brief_ready\n};\n\nconst cover = buildExecutiveCover(meta);\nconst htmlEmail = injectCoverIntoHtml(htmlEmailBase, cover);\nconst htmlFull  = injectCoverIntoHtml(htmlFullBase, cover);\n\nconst htmlB64 = Buffer.from(String(htmlFull), 'utf8').toString('base64');\n\n// TO\nlet toList = Array.isArray(j.to) ? j.to.filter(e => EMAIL_RE.test(String(e||''))) : [];\nif (!toList.length) {\n  const discovered = findUserEmail(j);\n  if (EMAIL_RE.test(discovered)) toList.push(discovered);\n}\nif (!toList.length) toList.push('misaac.torres@telefonica.com');\n\n// CC/BCC\nlet ccList = Array.isArray(j.cc) ? j.cc.filter(e => EMAIL_RE.test(String(e||''))) : [];\nconst bccList = Array.isArray(j.bcc) ? j.bcc.filter(e => EMAIL_RE.test(String(e||''))) : [];\n\n// CC fijo siempre\nconst alreadyHasAlways =\n  toList.includes(ALWAYS_CC) || ccList.includes(ALWAYS_CC) || bccList.includes(ALWAYS_CC);\nif (!alreadyHasAlways && EMAIL_RE.test(ALWAYS_CC)) ccList = [...ccList, ALWAYS_CC];\n\nconst payload = {\n  from: { email: FROM_EMAIL, name: FROM_NAME },\n  personalizations: [{\n    to: toList.map(email => ({ email })),\n    subject,\n    ...(ccList.length ? { cc: ccList.map(email => ({ email })) } : {}),\n    ...(bccList.length ? { bcc: bccList.map(email => ({ email })) } : {})\n  }],\n  content: [\n    { type: 'text/plain', value: `IA PARA TODOS ¬∑ AFTER ¬∑ Brief Ejecutivo\\nTema: ${feature_title}\\nHorizonte: ${qt}\\n\\nAdjunto el brief ejecutivo en HTML.` },\n    { type: 'text/html', value: htmlEmail }\n  ],\n  attachments: [\n    { content: htmlB64, type: 'text/html', filename: 'after-brief-ejecutivo.html', disposition: 'attachment' }\n  ],\n  mail_settings: { sandbox_mode: { enable: false } }\n};\n\n// ‚úÖ FIX: SendGrid devuelve 202 sin body; json:false evita parseo roto\nconst options = {\n  method: 'POST',\n  url: 'https://api.sendgrid.com/v3/mail/send',\n  headers: { Authorization: `Bearer ${SENDGRID_API_KEY}`, 'Content-Type': 'application/json' },\n  body: payload,\n  json: false,\n  resolveWithFullResponse: true,\n  simple: false\n};\n\nconst resp = await this.helpers.httpRequest(options);\n\n// SendGrid OK = 202\nconst ok = (resp?.statusCode === 202);\nreturn [{\n  json: {\n    ok,\n    statusCode: resp?.statusCode,\n    message: ok\n      ? `Email enviado (202) a ${toList.join(', ')} (CC: ${ccList.join(', ')})`\n      : `SendGrid respondi√≥ ${resp?.statusCode} (revisa body/headers)`,\n    to: toList, cc: ccList, bcc: bccList,\n    subject,\n    response_headers: resp?.headers || {},\n    response_body: resp?.body || \"\"\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -32,
        2416
      ],
      "id": "7a03c584-4815-4c24-b4f4-18130751901a",
      "name": "SendGrid Email (AFTER Brief)3"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Build Telegram Response ‚Äî alignment.discard v1.0 (n8n Cloud safe)\n * - Mensaje cuando gate=\"discard\" (score_total < 60)\n * - Explica por qu√© NO pasa, y da reto + formato m√≠nimo para replantear\n *\n * Input:  $json.output (Post-Merge envelope con alignment)\n * Output: $json.output.telegram.chat_id + $json.output.telegram.send_text\n */\n\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\nfunction pick(arr, n){ return Array.isArray(arr) ? arr.slice(0, n) : []; }\n\nfunction bullets(arr, max=6){\n  const xs = pick(arr || [], max).map(x => `‚Ä¢ ${normStr(x)}`).filter(Boolean);\n  return xs.length ? xs.join(\"\\n\") : \"\";\n}\n\nfunction topReasons(scores, rationale, max=3){\n  if (!isObj(scores)) return [];\n  const entries = Object.keys(scores).map(k => ({\n    k,\n    v: (typeof scores[k] === \"number\") ? scores[k] : 0,\n    r: isObj(rationale) ? normStr(rationale[k] || \"\") : \"\"\n  }));\n  // ordenar ascendente (peores)\n  entries.sort((a,b) => (a.v - b.v));\n  const worst = entries.slice(0, max);\n\n  const labelMap = {\n    impacto_estrategico: \"Impacto estrat√©gico\",\n    alineacion_vision_director: \"Alineaci√≥n visi√≥n director\",\n    viabilidad: \"Viabilidad\",\n    complejidad: \"Complejidad\",\n    prototipado_time_to_market: \"Prototipado / time-to-market\",\n    costos_dependencias: \"Costos / dependencias\",\n    probabilidad_exito_benchmark: \"Probabilidad (benchmark)\",\n    disrupcion: \"Disrupci√≥n\"\n  };\n\n  return worst.map(x => {\n    const lbl = labelMap[x.k] || x.k;\n    const why = x.r ? ` ‚Äî ${x.r}` : \"\";\n    return `‚Ä¢ ${lbl}: ${x.v}/100${why}`;\n  });\n}\n\nconst inItems = (typeof items !== \"undefined\" && Array.isArray(items)) ? items : $input.all();\nconst out = [];\n\nfor (const it of inItems){\n  const root = isObj(it.json) ? it.json : {};\n  const o = isObj(root.output) ? root.output : {};\n  const al = isObj(o.alignment) ? o.alignment : {};\n\n  const chat_id = normStr(o.chat_id || al.chat_id || \"\");\n  const idea = normStr(o._user_text || al._user_text || \"Idea/Feature\");\n  const score = (typeof al.score_total === \"number\") ? al.score_total : 0;\n\n  const scores = isObj(al.scores) ? al.scores : {};\n  const rationale = isObj(al.rationale) ? al.rationale : {};\n  const assumptions = Array.isArray(al.assumptions) ? al.assumptions : [];\n  const deps = Array.isArray(al.key_dependencies) ? al.key_dependencies : [];\n  const risks = Array.isArray(al.key_risks) ? al.key_risks : [];\n\n  const worst = topReasons(scores, rationale, 3);\n  const next = normStr(al.next_prompt_for_after || \"\");\n\n  const msg =\n`üß≠ Alignment Engine ‚Äî No aprobado (DESCARTADO)\n\nüìå Idea: ${idea}\nüìä Score: ${score} / 100\n‚õî No pasa a AFTER. Hoy no es una apuesta defendible frente a la direcci√≥n GTM.\n\nüß® Lo que no cuadra (vista del Director)\n${worst.length ? worst.join(\"\\n\") : \"‚Ä¢ Falta claridad para justificar impacto, viabilidad y alineaci√≥n.\"}\n\nüß© Supuestos actuales (por qu√© no se puede avanzar)\n${bullets(assumptions, 4) || \"‚Ä¢ (no especificados)\"}\n\nüîó Dependencias / Riesgos que dejan esto sin piso\n${bullets(deps, 3) || \"‚Ä¢ (pendiente)\"}${bullets(risks, 3) ? `\\n${bullets(risks, 3)}` : \"\"}\n\nüß± Reto obligatorio (replanteo m√≠nimo)\n${next || \"Replantea el concepto: objetivo, caso de uso y c√≥mo impacta caja/eficiencia/NPS/churn. Sin eso, no hay evaluaci√≥n real.\"}\n\nüìù Si quieres que lo re-eval√∫e, env√≠alo as√≠ (corto y concreto):\nTitulo: ...\nObjetivo (1 frase): ...\nCliente/Canal: ...\nProblema (dolor medible): ...\nKPI principal + umbral + ventana: ...\nDependencia #1: ...\nPiloto Sprint 1 (qu√© se mide): ...\n\n‚úÖ Luego escribe /continue\nCon ese input lo vuelvo a puntuar desde cero.`;\n\n  if (!isObj(o.telegram)) o.telegram = {};\n  o.telegram.chat_id = chat_id;\n  o.telegram.send_text = msg;\n\n  root.output = o;\n  out.push({ json: root });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        1536
      ],
      "id": "d19ea05b-8cf6-43d5-bb7e-ccf8720162e4",
      "name": "Build Telegram Response alignment.discard"
    },
    {
      "parameters": {
        "chatId": "={{ $json.output.telegram.chat_id }}",
        "text": "={{ $json.output.telegram.send_text }}",
        "additionalFields": {
          "parse_mode": "HTML"
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        -16,
        1536
      ],
      "id": "e555a495-134e-4e5b-a118-cdab2e2b0398",
      "name": "alignment.discard",
      "webhookId": "ad341579-20e1-4502-a663-98e9ed0385ba",
      "credentials": {
        "telegramApi": {
          "id": "X4qyKQtMSdDRIqOu",
          "name": "Agent After Bot"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * Telegram Message Splitter v1.1 ‚Äî n8n Cloud safe (HTML sanitizer opcional)\n * - Evita \"message is too long\" partiendo el texto en chunks seguros.\n * - FIX: si el nodo Telegram usa parse_mode=HTML, escapamos & < > para evitar:\n *   \"can't parse entities: Unsupported start tag ...\"\n *\n * Input esperado:\n *   $json.output.telegram.chat_id (o $json.output.chat_id)\n *   $json.output.telegram.send_text\n *\n * Output:\n *   m√∫ltiples items: { chat_id, text, part, parts_total }\n *\n * Config:\n *   MAX = 3500 (buffer bajo 4096)\n *   PARSE_MODE = \"NONE\" | \"HTML\"\n */\n\nfunction normStr(s){ return (s ?? \"\").toString(); }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\n\nconst MAX = 3500;\n\n// ‚úÖ Ajusta esto para que coincida con tu nodo Telegram\n// - Si tu Telegram node tiene Parse Mode = HTML => \"HTML\"\n// - Si no tiene parse mode => \"NONE\"\nconst PARSE_MODE = \"HTML\"; // \"NONE\" | \"HTML\"\n\nfunction escapeHtml(s){\n  // Orden importa: primero &, luego < >\n  return normStr(s)\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\");\n}\n\nfunction sanitizeForTelegram(text){\n  if (PARSE_MODE === \"HTML\") return escapeHtml(text);\n  return normStr(text);\n}\n\nfunction splitSmart(text, maxLen){\n  const t = normStr(text);\n  if (!t) return [\"\"];\n\n  const parts = [];\n  let remaining = t;\n\n  while (remaining.length > maxLen) {\n    const slice = remaining.slice(0, maxLen);\n\n    const cutCandidates = [\n      slice.lastIndexOf(\"\\n\\n\"),\n      slice.lastIndexOf(\"\\n\"),\n      slice.lastIndexOf(\". \"),\n      slice.lastIndexOf(\"; \"),\n      slice.lastIndexOf(\"‚Ä¢ \"),\n    ].filter(i => i > 50);\n\n    const cutAt = cutCandidates.length ? Math.max(...cutCandidates) : maxLen;\n\n    const chunk = remaining.slice(0, cutAt).trim();\n    parts.push(chunk);\n\n    remaining = remaining.slice(cutAt).trim();\n  }\n\n  if (remaining.length) parts.push(remaining);\n  return parts;\n}\n\nconst inItems = $input.all();\nconst out = [];\n\nfor (const it of inItems) {\n  const root = isObj(it.json) ? it.json : {};\n  const o = isObj(root.output) ? root.output : {};\n  const tg = isObj(o.telegram) ? o.telegram : {};\n\n  const chat_id = tg.chat_id || o.chat_id || root.chat_id || null;\n  const rawText = tg.send_text || o.send_text || root.send_text || \"\";\n\n  if (!chat_id) {\n    out.push({\n      json: { chat_id: null, text: \"‚ö†Ô∏è Error: falta chat_id para Telegram.\", part: 1, parts_total: 1 }\n    });\n    continue;\n  }\n\n  // ‚úÖ Sanitizar ANTES de partir (para conservar offsets)\n  const safeText = sanitizeForTelegram(rawText);\n\n  const parts = splitSmart(safeText, MAX);\n  const total = parts.length;\n\n  for (let i = 0; i < total; i++) {\n    const header = total > 1 ? `(${i+1}/${total}) ` : \"\";\n    out.push({\n      json: {\n        chat_id: String(chat_id),\n        text: header + parts[i],\n        part: i + 1,\n        parts_total: total,\n      }\n    });\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -32,
        1744
      ],
      "id": "9fa0c471-6eb1-4ee1-8d51-ea4e12223cd2",
      "name": "Msg Splitter2"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Telegram Message Splitter v1.0 ‚Äî n8n Cloud safe\n * - Evita \"Bad Request: message is too long\" partiendo el texto en chunks seguros\n *\n * Input esperado:\n *   $json.output.telegram.chat_id  (o $json.output.chat_id)\n *   $json.output.telegram.send_text\n *\n * Output:\n *   m√∫ltiples items, cada uno con:\n *     { chat_id, text, part, parts_total }\n *\n * Config:\n *   MAX = 3500 (safe buffer bajo 4096)\n */\n\nfunction normStr(s){ return (s ?? \"\").toString(); }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\n\nconst MAX = 3500;\n\nfunction splitSmart(text, maxLen){\n  const t = normStr(text);\n  if (!t) return [\"\"];\n\n  const parts = [];\n  let remaining = t;\n\n  while (remaining.length > maxLen) {\n    // intentamos cortar por separadores ‚Äúbonitos‚Äù\n    const slice = remaining.slice(0, maxLen);\n\n    const cutCandidates = [\n      slice.lastIndexOf(\"\\n\\n\"),\n      slice.lastIndexOf(\"\\n\"),\n      slice.lastIndexOf(\". \"),\n      slice.lastIndexOf(\"; \"),\n      slice.lastIndexOf(\"‚Ä¢ \"),\n    ].filter(i => i > 50); // evita cortes absurdos muy al inicio\n\n    const cutAt = cutCandidates.length ? Math.max(...cutCandidates) : maxLen;\n\n    const chunk = remaining.slice(0, cutAt).trim();\n    parts.push(chunk);\n\n    remaining = remaining.slice(cutAt).trim();\n  }\n\n  if (remaining.length) parts.push(remaining);\n  return parts;\n}\n\nconst inItems = $input.all();\nconst out = [];\n\nfor (const it of inItems) {\n  const root = isObj(it.json) ? it.json : {};\n  const o = isObj(root.output) ? root.output : {};\n  const tg = isObj(o.telegram) ? o.telegram : {};\n\n  const chat_id = tg.chat_id || o.chat_id || root.chat_id || null;\n  const text = tg.send_text || o.send_text || root.send_text || \"\";\n\n  if (!chat_id) {\n    out.push({ json: { chat_id: null, text: \"‚ö†Ô∏è Error: falta chat_id para Telegram.\", part: 1, parts_total: 1 }});\n    continue;\n  }\n\n  const parts = splitSmart(text, MAX);\n  const total = parts.length;\n\n  for (let i = 0; i < total; i++) {\n    // opcional: encabezado corto cuando son varios mensajes\n    const header = total > 1 ? `(${i+1}/${total}) ` : \"\";\n    out.push({\n      json: {\n        chat_id,\n        text: header + parts[i],\n        part: i + 1,\n        parts_total: total,\n      }\n    });\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -16,
        1184
      ],
      "id": "65ca71dd-2e40-4f12-ade8-9d75d21396bd",
      "name": "Msg Splitter3"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Build Telegram Response ‚Äî after.after_refinement v1.3.3\n * (100% din√°mico + validaci√≥n dura, pero tolera vac√≠os ‚Äúpermitidos‚Äù)\n *\n * FIX v1.3.3:\n * - sprint_plan viene con sprint_id (no sprint). Se soporta sprint_id/sprint/id.\n * - sprintLines NO rompe si no logra l√≠neas; devuelve instrucci√≥n accionable.\n *\n * Mantiene:\n * - Usa output.after_result (post-merge ya lo mapea)\n * - NO mete ‚Äúpendiente‚Äù\n * - Questions tolerante\n */\n\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\nfunction pick(arr, n){ return Array.isArray(arr) ? arr.slice(0, n) : []; }\n\nfunction reqStr(v, name){\n  const x = normStr(v);\n  if (!x) throw new Error(`AFTER telegram builder: falta string requerido: ${name}`);\n  return x;\n}\n\nfunction asArr(v){\n  if (Array.isArray(v)) return v;\n  const s = normStr(v);\n  return s ? [s] : [];\n}\n\nfunction reqArr(v, name, min=1){\n  const a = asArr(v);\n  if (a.length < min) throw new Error(`AFTER telegram builder: falta array requerido: ${name} (min ${min})`);\n  return a;\n}\n\nfunction bulletList(arr, max=6){\n  const xs = pick(asArr(arr), max).map(x => `‚Ä¢ ${normStr(x)}`).filter(Boolean);\n  if (!xs.length) throw new Error(\"AFTER telegram builder: bulletList vac√≠o (contrato roto)\");\n  return xs.join(\"\\n\");\n}\n\n// ‚úÖ FIX v1.3.3: sprintLines compatible con sprint_id y tolerante (NO revienta)\nfunction sprintLines(sprints, max=4){\n  const ss = asArr(sprints).filter(isObj);\n\n  const xs = pick(ss, max).map(sp => {\n    const sprint = normStr(sp.sprint_id || sp.sprint || sp.id || sp.name);\n    if (!sprint) return \"\";\n\n    const goals = Array.isArray(sp.goals) ? sp.goals.map(normStr).filter(Boolean) : [];\n    const deliver = Array.isArray(sp.deliverables) ? sp.deliverables.map(normStr).filter(Boolean) : [];\n\n    const g0 = goals[0] || \"\";\n    const d0 = deliver[0] || \"\";\n\n    const hr = isObj(sp.hours_range) ? sp.hours_range : null;\n    const hmin = hr?.min, hmax = hr?.max;\n    const hTxt = (typeof hmin === \"number\" && typeof hmax === \"number\") ? ` (${hmin}-${hmax}h)` : \"\";\n\n    if (!g0 && !d0) return `‚Ä¢ ${sprint}${hTxt}`;\n    return `‚Ä¢ ${sprint}${hTxt}: ${g0}${d0 ? ` ‚Äî ${d0}` : \"\"}`;\n  }).filter(Boolean);\n\n  if (!xs.length) {\n    return \"‚Ä¢ No se pudo imprimir el plan por sprints (faltan campos esperados). Pide al agente: ‚ÄúGenera sprint_plan con sprint_id (SP00..), goals y deliverables por sprint‚Äù y luego escribe /after.\";\n  }\n\n  return xs.join(\"\\n\");\n}\n\n// ‚úÖ FIX: storyLines tolerante (no rompe si faltan campos / vienen menos historias)\nfunction storyLines(stories, max=8){\n  const ss = asArr(stories).filter(isObj);\n\n  const xs = pick(ss, max).map(us => {\n    const id = normStr(us.id);\n    const title = normStr(us.title);\n    const size = normStr(us.size);\n\n    const hr = isObj(us.hours_range) ? us.hours_range : null;\n    const hmin = hr?.min, hmax = hr?.max;\n\n    // Si est√° incompleta, la ignoramos (no reventamos el builder)\n    if (!id || !title || !size) return \"\";\n    if (typeof hmin !== \"number\" || typeof hmax !== \"number\") return \"\";\n\n    return `‚Ä¢ ${id} (${size} ${hmin}-${hmax}h) ‚Äî ${title}`;\n  }).filter(Boolean);\n\n  if (!xs.length) {\n    return \"‚Ä¢ No se reportaron Historias de Usuario estimables en esta iteraci√≥n. Solicita al agente generar m√≠nimo 6 HUs con rango de horas por HU.\";\n  }\n\n  return xs.join(\"\\n\");\n}\n\nfunction computeTotalRangeFromStories(stories){\n  const ss = asArr(stories).filter(isObj);\n  let min = 0, max = 0, ok = false;\n\n  for (const us of ss){\n    const hr = isObj(us.hours_range) ? us.hours_range : null;\n    if (!hr) continue;\n    const hmin = hr.min, hmax = hr.max;\n    if (typeof hmin === \"number\" && typeof hmax === \"number\"){\n      min += hmin;\n      max += hmax;\n      ok = true;\n    }\n  }\n  return ok ? { min, max } : null;\n}\n\n// ‚úÖ preguntas compatibles, sin romper contrato si vienen vac√≠as\nfunction getQuestions(ar, o){\n  const q1 = asArr(ar?.questions).map(normStr).filter(Boolean);\n  if (q1.length) return q1;\n\n  const q2 = asArr(ar?.power_questions).map(normStr).filter(Boolean);\n  if (q2.length) return q2;\n\n  const q3 = asArr(o?.alignment?.power_questions).map(normStr).filter(Boolean);\n  if (q3.length) return q3;\n\n  return [];\n}\n\nconst inItems = $input.all();\nconst out = [];\n\nfor (const it of inItems) {\n  const root = isObj(it.json) ? it.json : {};\n  const o = isObj(root.output) ? root.output : {};\n  const ar = isObj(o.after_result) ? o.after_result : null;\n\n  if (!ar) throw new Error(\"AFTER telegram builder: falta output.after_result (post-merge no lo pobl√≥)\");\n\n  const chat_id = reqStr(o.chat_id, \"output.chat_id\");\n\n  const title = reqStr(ar.feature_title || ar.idea_text || o.idea_text || o._user_text, \"after_result.feature_title|idea_text\");\n  const summary = reqStr(ar.executive_summary, \"after_result.executive_summary\");\n\n  // Requeridos (duros)\n  const puntos = reqArr(ar.checkpoints_obligatorios, \"after_result.checkpoints_obligatorios\", 5);\n  const kpis = reqArr(ar.recommended_kpis, \"after_result.recommended_kpis\", 3);\n  const sprints = reqArr(ar.sprint_plan, \"after_result.sprint_plan\", 3);\n\n  // ‚úÖ FIX: user_stories NO revienta si viene < 6 o incompleto\n  const storiesRaw = Array.isArray(ar.user_stories) ? ar.user_stories : [];\n  const storiesValid = storiesRaw.filter(isObj).filter(us => {\n    const hr = isObj(us.hours_range) ? us.hours_range : null;\n    const okHr = typeof hr?.min === \"number\" && typeof hr?.max === \"number\";\n    return !!normStr(us.id) && !!normStr(us.title) && !!normStr(us.size) && okHr;\n  });\n\n  const storiesCount = storiesValid.length;\n  const storiesQualityNote = (storiesCount >= 6)\n    ? \"\"\n    : `\\n\\nüß© Calidad de desglose (acci√≥n requerida)\\n‚Ä¢ Historias v√°lidas: ${storiesCount}/6 (recomendado: ‚â•6)\\n‚Ä¢ Para continuar: pide al agente ‚ÄúGenera m√≠nimo 6 HUs estimables con hours_range min/max y criterios de aceptaci√≥n‚Äù y luego escribe /after.`;\n\n  // Gaps tolerante\n  const gapsRaw = asArr(ar.gaps_blocking_ready).map(normStr).filter(Boolean);\n  const gaps = gapsRaw.length\n    ? gapsRaw\n    : [\"Sin gaps cr√≠ticos reportados por el agente en esta iteraci√≥n (valida con evidencia y owners).\"];\n\n  // Dependencias/Riesgos tolerante con compat\n  const depsRaw = asArr(ar.key_dependencies).length ? asArr(ar.key_dependencies) : asArr(ar.dependencies);\n  const risksRaw = asArr(ar.key_risks).length ? asArr(ar.key_risks) : asArr(ar.risks);\n\n  const deps = depsRaw.length\n    ? depsRaw\n    : [\"No se reportaron dependencias expl√≠citas en esta iteraci√≥n (define owner #1, fecha y entregable verificable).\"];\n\n  const risks = risksRaw.length\n    ? risksRaw\n    : [\"No se reportaron riesgos expl√≠citos en esta iteraci√≥n (valida costo OTT, fraude/abuso y experiencia de activaci√≥n).\"];\n\n  // Preguntas tolerantes\n  const questions = getQuestions(ar, o);\n\n  let qBlock = \"\";\n  if (questions.length) {\n    const qLines = pick(questions, 8).map((q, i) => `A${i+1}: ${normStr(q)}`).filter(Boolean).join(\"\\n\");\n    if (!qLines) throw new Error(\"AFTER telegram builder: preguntas presentes pero sin l√≠neas (contrato roto)\");\n    qBlock =\n`‚ùì Resp√≥ndeme esto (corto y directo)\n${qLines}`;\n  } else {\n    qBlock =\n`‚ùì Para continuar el refinamiento (sin preguntas generadas en esta iteraci√≥n)\nA1: Confirma 3 KPIs con umbral (baseline, target, ventana).\nA2: Confirma owner #1 de Billing/Pagos y fecha de habilitaci√≥n.\nA3: Define guardrails financieros (ARPU floor o margen m√≠nimo).`;\n  }\n\n  // CTA din√°mico\n  let next = normStr(ar.next_user_instruction);\n  if (!next){\n    next = \"Responde A1..Ax y luego escribe /after\";\n  }\n\n  // Total range: si falta/null, calcular desde historias v√°lidas; si no se puede, NO fallar\n  let totalRange = ar.macro_estimation_hours_total_range;\n  const totalRangeOk = isObj(totalRange) && typeof totalRange.min === \"number\" && typeof totalRange.max === \"number\";\n\n  if (!totalRangeOk) {\n    const computed = computeTotalRangeFromStories(storiesValid);\n    if (computed) totalRange = computed;\n  }\n\n  const totalLine = (isObj(totalRange) && typeof totalRange.min === \"number\" && typeof totalRange.max === \"number\")\n    ? `Total estimado: ${totalRange.min}-${totalRange.max}h`\n    : \"Total estimado: no calculable (faltan HUs con hours_range min/max o total no fue provisto por el agente)\";\n\n  const msg =\n`üõ†Ô∏è AFTER ‚Äî Refinamiento en curso\n\nüìå Feature: ${title}\n\nüß† Resumen\n${summary}\n\nüéØ Puntos de control obligatorios (para READY)\n${bulletList(puntos, 6)}\n\nüß© Gaps que bloquean READY\n${bulletList(gaps, 6)}\n\nüìà KPIs recomendados (gobierno)\n${bulletList(kpis, 5)}\n\nüß© Dependencias principales\n${bulletList(deps, 4)}\n\n‚ö†Ô∏è Riesgos a vigilar\n${bulletList(risks, 3)}\n\nüó∫Ô∏è Plan por sprints\n${sprintLines(sprints, 4)}\n\nüßæ Macro-estimaci√≥n (HUs + horas)\n${totalLine}\n${storyLines(storiesValid, 8)}${storiesQualityNote}\n\n${qBlock}\n\nüß≠ Siguiente paso\n${next}`;\n\n  if (!isObj(o.telegram)) o.telegram = {};\n  o.telegram.chat_id = chat_id;\n  o.telegram.send_text = msg;\n\n  root.output = o;\n  out.push({ json: root });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        1744
      ],
      "id": "88955d47-6098-4ec7-85ec-38774d8414d3",
      "name": "Build Telegram Response after.after_refinment1"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Build Telegram Response ‚Äî alignment.after_refine v1.2 (idea_text first)\n * - Confirma que la idea pasa (>=80)\n * - Resume: score + racional director (compacto) + KPIs + dependencias + riesgos + readiness\n * - CTA √∫nico: /after\n * - Sin Markdown, con emoticones\n * FIX:\n * - \"Idea:\" usa idea_text (base) en vez de _user_text (que puede ser A1/A2...)\n */\n\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\nfunction pick(arr, n){ return Array.isArray(arr) ? arr.slice(0, n) : []; }\n\nfunction compactOneLine(s, maxLen=140){\n  const x = normStr(s).replace(/\\s+/g, \" \");\n  if (!x) return \"\";\n  return x.length > maxLen ? (x.slice(0, maxLen-1) + \"‚Ä¶\") : x;\n}\n\nfunction buildRationaleBullets(rationaleObj){\n  if (!isObj(rationaleObj)) return [];\n\n  const order = [\n    [\"impacto_estrategico\", \"Impacto\"],\n    [\"alineacion_vision_director\", \"Alineaci√≥n GTM\"],\n    [\"viabilidad\", \"Viabilidad\"],\n    [\"prototipado_time_to_market\", \"Time-to-market\"],\n    [\"costos_dependencias\", \"Costos/Dependencias\"],\n    [\"complejidad\", \"Complejidad\"],\n    [\"probabilidad_exito_benchmark\", \"Prob. √©xito\"],\n    [\"disrupcion\", \"Diferencial\"]\n  ];\n\n  const bullets = [];\n  for (const [k, label] of order) {\n    const txt = compactOneLine(rationaleObj[k], 150);\n    if (txt) bullets.push(`‚Ä¢ ${label}: ${txt}`);\n    if (bullets.length >= 6) break;\n  }\n  return bullets;\n}\n\nconst inItems = $input.all();\nconst out = [];\n\nfor (const it of inItems) {\n  const root = isObj(it.json) ? it.json : {};\n  const o = isObj(root.output) ? root.output : {};\n  const a = isObj(o.alignment) ? o.alignment : {};\n  const h = isObj(a.handoff) ? a.handoff : {};\n\n  const chat_id = o.chat_id;\n\n  // ‚úÖ FIX: t√≠tulo debe ser la idea base (idea_text) y NO _user_text (respuestas A1/A2)\n  const title = normStr(\n    a.idea_text ||              // alignment_v2_4\n    a.output?.idea_text ||      // por si viene anidado\n    o.idea_text ||              // expuesto por post-merge v1.4\n    o.output?.idea_text ||      // compat\n    a._user_text ||             // fallback\n    o._user_text ||             // fallback\n    \"Idea\"\n  );\n\n  const score = (typeof a.score_total === \"number\") ? a.score_total : null;\n\n  const rationaleBullets = buildRationaleBullets(a.rationale || {});\n  const rationaleTxt = rationaleBullets.length ? rationaleBullets.join(\"\\n\") : \"\";\n\n  const kpis = pick(a.recommended_kpis || [], 5).map(x => `‚Ä¢ ${normStr(x)}`).filter(Boolean).join(\"\\n\");\n  const deps = pick(a.key_dependencies || [], 3).map(x => `‚Ä¢ ${normStr(x)}`).filter(Boolean).join(\"\\n\");\n  const risks = pick(a.key_risks || [], 2).map(x => `‚Ä¢ ${normStr(x)}`).filter(Boolean).join(\"\\n\");\n\n  const readiness = pick(h.readiness_criteria_min || [], 5).map(x => `‚Ä¢ ${normStr(x)}`).filter(Boolean).join(\"\\n\");\n  const passes = (typeof h.min_refinement_passes === \"number\") ? h.min_refinement_passes : 1;\n\n  const msg =\n`‚úÖ Alignment aprobado\n\nüìå Idea: ${title}\nüìä Score: ${score !== null ? score : \"N/A\"} / 100\nüéØ Decisi√≥n: pasa a refinamiento (AFTER).\n\nüßæ Racional (visi√≥n Direcci√≥n GTM)\n${rationaleTxt ? rationaleTxt : \"‚Ä¢ (pendiente racional ejecutivo por criterio)\"}\n\nüìà KPIs recomendados para gobernar el piloto\n${kpis ? kpis : \"‚Ä¢ (pendiente definir KPIs operables)\"}\n\nüß© Dependencias principales\n${deps ? deps : \"‚Ä¢ (pendiente confirmar dependencias t√©cnicas)\"}\n\n‚ö†Ô∏è Riesgos a vigilar\n${risks ? risks : \"‚Ä¢ (pendiente concretar riesgos cr√≠ticos)\"}\n\nüß∞ Checklist m√≠nimo antes de cerrar brief\n${readiness ? readiness : \"‚Ä¢ (pendiente criterios m√≠nimos de readiness)\"}\n\nüß≠ Siguiente paso\nEscribe /after para iniciar el refinamiento: hip√≥tesis, HUs sugeridas, capacidad/tiempos y trade-offs.\n(Iteraciones m√≠nimas sugeridas: ${passes}).`;\n\n  if (!isObj(o.telegram)) o.telegram = {};\n  o.telegram.chat_id = chat_id;\n  o.telegram.send_text = msg;\n\n  root.output = o;\n  out.push({ json: root });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        1184
      ],
      "id": "5d5d5738-9902-4864-bf2c-a4c55d602132",
      "name": "Build Telegram Response ‚Äî alignment.after_refine1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1920,
        2480
      ],
      "id": "3faa6ee8-4b4b-4277-81d7-330eeeb815eb",
      "name": "OpenAI LLM AFTER Agent6",
      "credentials": {
        "openAiApi": {
          "id": "d580cWdgashlSAET",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.message.from.id }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -1728,
        2480
      ],
      "id": "c87f40b7-629e-45a0-9f77-3e696af746f0",
      "name": "Simple Memory LLM AFTER Agent6"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"name\": \"after_v2_1\",\n  \"strict\": true,\n  \"schema\": {\n    \"type\": \"object\",\n    \"additionalProperties\": false,\n    \"required\": [\n      \"chat_id\",\n      \"state\",\n      \"feature_title\",\n      \"idea_text\",\n      \"brief_ready\",\n      \"executive_summary\",\n      \"readiness_criteria_min\",\n      \"checkpoints_obligatorios\",\n      \"gaps_blocking_ready\",\n      \"key_dependencies\",\n      \"key_risks\",\n      \"recommended_kpis\",\n      \"sprint_plan\",\n      \"brief\",\n      \"user_stories\",\n      \"macro_estimation_hours_total_range\",\n      \"questions\",\n      \"next_user_instruction\"\n    ],\n    \"properties\": {\n      \"chat_id\": { \"type\": \"string\", \"minLength\": 3 },\n      \"state\": { \"type\": \"string\", \"enum\": [\"after_refinement\", \"after_brief\"] },\n      \"feature_title\": { \"type\": \"string\", \"minLength\": 6 },\n      \"idea_text\": { \"type\": \"string\", \"minLength\": 6 },\n      \"brief_ready\": { \"type\": \"boolean\" },\n      \"executive_summary\": { \"type\": \"string\", \"minLength\": 30 },\n\n      \"readiness_criteria_min\": {\n        \"type\": \"array\",\n        \"minItems\": 6,\n        \"maxItems\": 12,\n        \"items\": { \"type\": \"string\", \"minLength\": 10 }\n      },\n      \"checkpoints_obligatorios\": {\n        \"type\": \"array\",\n        \"minItems\": 5,\n        \"maxItems\": 12,\n        \"items\": { \"type\": \"string\", \"minLength\": 10 }\n      },\n      \"gaps_blocking_ready\": {\n        \"type\": \"array\",\n        \"minItems\": 0,\n        \"maxItems\": 12,\n        \"items\": { \"type\": \"string\", \"minLength\": 10 }\n      },\n      \"key_dependencies\": {\n        \"type\": \"array\",\n        \"minItems\": 1,\n        \"maxItems\": 12,\n        \"items\": { \"type\": \"string\", \"minLength\": 10 }\n      },\n      \"key_risks\": {\n        \"type\": \"array\",\n        \"minItems\": 1,\n        \"maxItems\": 12,\n        \"items\": { \"type\": \"string\", \"minLength\": 10 }\n      },\n      \"recommended_kpis\": {\n        \"type\": \"array\",\n        \"minItems\": 3,\n        \"maxItems\": 12,\n        \"items\": { \"type\": \"string\", \"minLength\": 10 }\n      },\n      \"sprint_plan\": {\n        \"type\": \"array\",\n        \"minItems\": 3,\n        \"maxItems\": 6,\n        \"items\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false,\n          \"required\": [\"sprint\", \"goals\", \"deliverables\"],\n          \"properties\": {\n            \"sprint\": { \"type\": \"string\", \"minLength\": 3 },\n            \"goals\": {\n              \"type\": \"array\",\n              \"minItems\": 2,\n              \"maxItems\": 6,\n              \"items\": { \"type\": \"string\", \"minLength\": 10 }\n            },\n            \"deliverables\": {\n              \"type\": \"array\",\n              \"minItems\": 2,\n              \"maxItems\": 8,\n              \"items\": { \"type\": \"string\", \"minLength\": 10 }\n            }\n          }\n        }\n      },\n\n      \"brief\": {\n        \"type\": \"object\",\n        \"additionalProperties\": false,\n        \"required\": [\"objectives\"],\n        \"properties\": {\n          \"objectives\": {\n            \"type\": \"array\",\n            \"minItems\": 3,\n            \"maxItems\": 8,\n            \"items\": { \"type\": \"string\", \"minLength\": 10 }\n          }\n        }\n      },\n\n      \"user_stories\": {\n        \"type\": \"array\",\n        \"minItems\": 6,\n        \"maxItems\": 20,\n        \"items\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false,\n          \"required\": [\"id\", \"title\", \"description\", \"size\", \"hours_range\", \"acceptance\"],\n          \"properties\": {\n            \"id\": { \"type\": \"string\", \"minLength\": 3 },\n            \"title\": { \"type\": \"string\", \"minLength\": 8 },\n            \"description\": { \"type\": \"string\", \"minLength\": 30 },\n            \"size\": { \"type\": \"string\", \"enum\": [\"S\", \"M\", \"L\", \"XL\"] },\n            \"hours_range\": {\n              \"type\": \"object\",\n              \"additionalProperties\": false,\n              \"required\": [\"min\", \"max\"],\n              \"properties\": {\n                \"min\": { \"type\": \"number\", \"minimum\": 1 },\n                \"max\": { \"type\": \"number\", \"minimum\": 1 }\n              }\n            },\n            \"acceptance\": {\n              \"type\": \"array\",\n              \"minItems\": 2,\n              \"maxItems\": 6,\n              \"items\": { \"type\": \"string\", \"minLength\": 10 }\n            }\n          }\n        }\n      },\n\n      \"macro_estimation_hours_total_range\": {\n        \"type\": \"object\",\n        \"additionalProperties\": false,\n        \"required\": [\"min\", \"max\"],\n        \"properties\": {\n          \"min\": { \"type\": \"number\", \"minimum\": 1 },\n          \"max\": { \"type\": \"number\", \"minimum\": 1 }\n        }\n      },\n\n      \"questions\": {\n        \"type\": \"array\",\n        \"minItems\": 0,\n        \"maxItems\": 8,\n        \"items\": { \"type\": \"string\", \"minLength\": 12 }\n      },\n\n      \"next_user_instruction\": { \"type\": \"string\", \"minLength\": 12 },\n\n      \"impact_scorecard\": {\n        \"type\": \"array\",\n        \"minItems\": 5,\n        \"maxItems\": 5,\n        \"items\": {\n          \"type\": \"object\",\n          \"additionalProperties\": false,\n          \"required\": [\"dimension\", \"score\", \"stars\", \"rationale\"],\n          \"properties\": {\n            \"dimension\": {\n              \"type\": \"string\",\n              \"enum\": [\"Roles\", \"Procesos\", \"Estrategia\", \"Cliente\", \"Tecnologia\"]\n            },\n            \"score\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 5 },\n            \"stars\": { \"type\": \"string\", \"minLength\": 5, \"maxLength\": 5 },\n            \"rationale\": { \"type\": \"string\", \"minLength\": 20 }\n          }\n        }\n      },\n\n      \"impact_score_overall\": {\n        \"type\": \"object\",\n        \"additionalProperties\": false,\n        \"required\": [\"avg\", \"stars\"],\n        \"properties\": {\n          \"avg\": { \"type\": \"number\", \"minimum\": 1, \"maximum\": 5 },\n          \"stars\": { \"type\": \"string\", \"minLength\": 5, \"maxLength\": 5 }\n        }\n      }\n    },\n\n    \"allOf\": [\n      {\n        \"if\": { \"properties\": { \"brief_ready\": { \"const\": false } }, \"required\": [\"brief_ready\"] },\n        \"then\": {\n          \"properties\": {\n            \"gaps_blocking_ready\": { \"minItems\": 1 },\n            \"questions\": { \"minItems\": 3 }\n          }\n        }\n      },\n      {\n        \"if\": { \"properties\": { \"brief_ready\": { \"const\": true } }, \"required\": [\"brief_ready\"] },\n        \"then\": {\n          \"required\": [\"impact_scorecard\", \"impact_score_overall\"],\n          \"properties\": {\n            \"gaps_blocking_ready\": { \"maxItems\": 0 }\n          }\n        }\n      }\n    ]\n  }\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -1552,
        2480
      ],
      "id": "9aa11d65-4913-4e0b-a1eb-6592628a57a9",
      "name": "Structured Output Parser LLM AFTER Agent5"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -1920,
        1616
      ],
      "id": "c39b47b6-e54d-49b9-8030-657115930300",
      "name": "OpenAI LLM Alignment Engine5",
      "credentials": {
        "openAiApi": {
          "id": "d580cWdgashlSAET",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.message.from.id }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        -1760,
        1616
      ],
      "id": "79932b63-0577-4158-8438-60e604c55daa",
      "name": "Simple Memory LLM Alignment Engine5"
    },
    {
      "parameters": {
        "schemaType": "manual",
        "inputSchema": "{\n  \"name\": \"alignment_v2_4\",\n  \"strict\": true,\n  \"schema\": {\n    \"type\": \"object\",\n    \"additionalProperties\": false,\n    \"required\": [\n      \"chat_id\",\n      \"_user_text\",\n      \"idea_text\",\n      \"state\",\n      \"gate\",\n      \"score_total\",\n      \"weights_used\",\n      \"scores\",\n      \"rationale\",\n      \"assumptions\",\n      \"key_dependencies\",\n      \"key_risks\",\n      \"recommended_kpis\",\n      \"power_questions\",\n      \"next_prompt_for_after\",\n      \"handoff\"\n    ],\n    \"properties\": {\n      \"chat_id\": { \"type\": \"string\" },\n      \"_user_text\": { \"type\": \"string\" },\n      \"idea_text\": { \"type\": \"string\" },\n\n      \"state\": { \"type\": \"string\", \"enum\": [\"alignment_result\"] },\n      \"gate\": { \"type\": \"string\", \"enum\": [\"after_refine\", \"clarify\", \"discard\"] },\n      \"score_total\": { \"type\": \"number\", \"minimum\": 0, \"maximum\": 100 },\n\n      \"weights_used\": {\n        \"type\": \"object\",\n        \"additionalProperties\": false,\n        \"required\": [\n          \"impacto_estrategico\",\n          \"alineacion_vision_director\",\n          \"viabilidad\",\n          \"complejidad\",\n          \"prototipado_time_to_market\",\n          \"costos_dependencias\",\n          \"probabilidad_exito_benchmark\",\n          \"disrupcion\"\n        ],\n        \"properties\": {\n          \"impacto_estrategico\": { \"type\": \"number\" },\n          \"alineacion_vision_director\": { \"type\": \"number\" },\n          \"viabilidad\": { \"type\": \"number\" },\n          \"complejidad\": { \"type\": \"number\" },\n          \"prototipado_time_to_market\": { \"type\": \"number\" },\n          \"costos_dependencias\": { \"type\": \"number\" },\n          \"probabilidad_exito_benchmark\": { \"type\": \"number\" },\n          \"disrupcion\": { \"type\": \"number\" }\n        }\n      },\n\n      \"scores\": {\n        \"type\": \"object\",\n        \"additionalProperties\": false,\n        \"required\": [\n          \"impacto_estrategico\",\n          \"alineacion_vision_director\",\n          \"viabilidad\",\n          \"complejidad\",\n          \"prototipado_time_to_market\",\n          \"costos_dependencias\",\n          \"probabilidad_exito_benchmark\",\n          \"disrupcion\"\n        ],\n        \"properties\": {\n          \"impacto_estrategico\": { \"type\": \"number\", \"minimum\": 0, \"maximum\": 100 },\n          \"alineacion_vision_director\": { \"type\": \"number\", \"minimum\": 0, \"maximum\": 100 },\n          \"viabilidad\": { \"type\": \"number\", \"minimum\": 0, \"maximum\": 100 },\n          \"complejidad\": { \"type\": \"number\", \"minimum\": 0, \"maximum\": 100 },\n          \"prototipado_time_to_market\": { \"type\": \"number\", \"minimum\": 0, \"maximum\": 100 },\n          \"costos_dependencias\": { \"type\": \"number\", \"minimum\": 0, \"maximum\": 100 },\n          \"probabilidad_exito_benchmark\": { \"type\": \"number\", \"minimum\": 0, \"maximum\": 100 },\n          \"disrupcion\": { \"type\": \"number\", \"minimum\": 0, \"maximum\": 100 }\n        }\n      },\n\n      \"rationale\": {\n        \"type\": \"object\",\n        \"additionalProperties\": false,\n        \"required\": [\n          \"impacto_estrategico\",\n          \"alineacion_vision_director\",\n          \"viabilidad\",\n          \"complejidad\",\n          \"prototipado_time_to_market\",\n          \"costos_dependencias\",\n          \"probabilidad_exito_benchmark\",\n          \"disrupcion\"\n        ],\n        \"properties\": {\n          \"impacto_estrategico\": { \"type\": \"string\" },\n          \"alineacion_vision_director\": { \"type\": \"string\" },\n          \"viabilidad\": { \"type\": \"string\" },\n          \"complejidad\": { \"type\": \"string\" },\n          \"prototipado_time_to_market\": { \"type\": \"string\" },\n          \"costos_dependencias\": { \"type\": \"string\" },\n          \"probabilidad_exito_benchmark\": { \"type\": \"string\" },\n          \"disrupcion\": { \"type\": \"string\" }\n        }\n      },\n\n      \"assumptions\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"maxItems\": 12 },\n      \"key_dependencies\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"maxItems\": 12 },\n      \"key_risks\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"maxItems\": 12 },\n      \"recommended_kpis\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"maxItems\": 12 },\n      \"power_questions\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"maxItems\": 8 },\n      \"next_prompt_for_after\": { \"type\": \"string\" },\n\n      \"handoff\": {\n        \"type\": \"object\",\n        \"additionalProperties\": false,\n        \"required\": [\"recommended_after_state\", \"min_refinement_passes\", \"readiness_criteria_min\"],\n        \"properties\": {\n          \"recommended_after_state\": { \"type\": \"string\", \"enum\": [\"after_refinement\"] },\n          \"min_refinement_passes\": { \"type\": \"integer\", \"minimum\": 1, \"maximum\": 5 },\n          \"readiness_criteria_min\": { \"type\": \"array\", \"items\": { \"type\": \"string\" }, \"maxItems\": 12 }\n        }\n      }\n    }\n  }\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        -1568,
        1616
      ],
      "id": "e0534805-2b40-440e-bbc6-2d2073c453db",
      "name": "Structured Output Parser LLM Alignment Engine4"
    },
    {
      "parameters": {
        "jsCode": "/**\n * TG Normalize n Route Intent v4.3 (PATCH: respuestas no se van a Alignment cuando el objetivo es AFTER)\n * Mantiene lo que ya funciona y corrige SOLO esto:\n * 1) Si el usuario responde A1/A2... y pone /after (al final o en l√≠nea aparte),\n *    esas l√≠neas NO son ‚Äúidea‚Äù; son clarify_answers_text para el AFTER LLM.\n * 2) Si estamos en modo AFTER y el usuario manda respuestas (A1/A2...) SIN comando,\n *    se enruta a intent=\"after\" + after_action=\"continue\" (no a alignment).\n * 3) Se asegura output.idea_text ‚Äúvivo‚Äù para el AFTER LLM (sin contaminarlo con respuestas).\n *\n * NOTA: no crea nodos nuevos, no cambia routing_key, no cambia reglas de greeting/reset.\n */\n\nfunction coalesce(...args) { for (const v of args) if (v !== undefined && v !== null && v !== \"\") return v; return null; }\nfunction normStr(s) { return (s ?? \"\").toString().trim(); }\nfunction normLower(s) { return normStr(s).toLowerCase(); }\nfunction isObj(v) { return typeof v === \"object\" && v !== null && !Array.isArray(v); }\n\nfunction getIncomingText(j) {\n  const tgText = coalesce(j.message?.text, j.callback_query?.data, j.text);\n  return normStr(coalesce(j._user_text, j.output?._user_text, tgText, j.body?.text, \"\"));\n}\n\nfunction getReplyText(j){\n  return normStr(\n    coalesce(\n      j.reply_text,\n      j.message?.reply_to_message?.text,\n      j.callback_query?.message?.reply_to_message?.text,\n      \"\"\n    )\n  );\n}\n\nfunction getChatId(j) {\n  const tgChatId = coalesce(j.message?.chat?.id, j.callback_query?.message?.chat?.id);\n  const cid = coalesce(j.chat_id, j.output?.chat_id, tgChatId, null);\n  return (cid === null || cid === undefined) ? null : cid;\n}\n\n// ---------- Detectores ----------\nfunction detectGreeting(t) {\n  const x = normLower(t);\n  if (!x) return false;\n  const greetings = [\"hola\",\"buenas\",\"buenos dias\",\"buenas tardes\",\"buenas noches\",\"hi\",\"hello\",\"hey\",\"que tal\",\"qu√© tal\",\"buen d√≠a\",\"buen dia\"];\n  if (greetings.includes(x)) return true;\n  if (x.length <= 18 && greetings.some(g => x.startsWith(g))) return true;\n  return false;\n}\n\n// comando como token de l√≠nea\nfunction hasLineCommand(text, cmd) {\n  const t = (text ?? \"\").toString();\n  const re = new RegExp(`(^|\\\\n)\\\\s*\\\\/${cmd}(\\\\s|$)`, \"i\");\n  return re.test(t);\n}\n\nfunction detectAfterAction(text) {\n  const raw = normStr(text);\n  const t = normLower(raw);\n\n  // brief ejecutivo (alias)\n  if (hasLineCommand(raw, \"briefejecutivo\") || t.startsWith(\"/briefejecutivo\")) return \"brief\";\n  if (hasLineCommand(raw, \"brief\") || t.includes(\"after brief\") || t.includes(\"generar brief\") || t.includes(\"after_brief\")) return \"brief\";\n\n  // continue / clarify\n  if (hasLineCommand(raw, \"continue\") || hasLineCommand(raw, \"continuar\") || t.includes(\"after_continue\")) return \"continue\";\n  if (hasLineCommand(raw, \"clarify\") || hasLineCommand(raw, \"aclarar\") || t.includes(\"after_clarify\")) return \"clarify\";\n\n  // after refine\n  if (hasLineCommand(raw, \"after\") || t.includes(\"after_refine\")) return \"refine\";\n\n  // inline\n  if (t.startsWith(\"/brief\")) return \"brief\";\n  if (t.startsWith(\"/continue\") || t.startsWith(\"/continuar\")) return \"continue\";\n  if (t.startsWith(\"/clarify\") || t.startsWith(\"/aclarar\")) return \"clarify\";\n  if (t.startsWith(\"/after\") || t.startsWith(\"after:\") || t.startsWith(\"after \")) return \"refine\";\n\n  return null;\n}\n\n/**\n * Mantiene tu regla original:\n * - continue/clarify => alignment\n * - refine/brief => after\n */\nfunction detectIntentAndAction(text) {\n  const raw = normStr(text);\n\n  if (hasLineCommand(raw, \"reset\") || normLower(raw).startsWith(\"/reset\")) return { intent: \"greeting\", after_action: null, reset: true };\n  if (detectGreeting(raw)) return { intent: \"greeting\", after_action: null, reset: false };\n\n  const after_action = detectAfterAction(raw);\n\n  if (after_action === \"continue\" || after_action === \"clarify\") {\n    return { intent: \"alignment\", after_action, reset: false };\n  }\n\n  if (after_action) return { intent: \"after\", after_action, reset: false };\n\n  return { intent: \"alignment\", after_action: null, reset: false };\n}\n\n// Remueve l√≠neas que sean SOLO comandos, para obtener body_text real\nfunction stripCommandLines(raw) {\n  const lines = (raw ?? \"\").toString().split(\"\\n\");\n  const cmdRe = /^\\s*\\/(after|brief|briefejecutivo|continue|continuar|clarify|aclarar|reset)\\s*$/i;\n  const kept = lines.filter(l => !cmdRe.test(l));\n  return normStr(kept.join(\"\\n\"));\n}\n\nfunction looksLikeAnswers(t){\n  const x = normStr(t);\n  if (!x) return false;\n  if (/^(A1:|A2:|A3:|A4:|A5:|A6:|A7:|A8:|Q1:|Q2:|Q3:|Q4:|Q5:|Q6:|Q7:|Q8:)/i.test(x)) return true;\n  if (x.includes(\"\\nA1:\") || x.includes(\"\\nA2:\") || x.includes(\"\\nQ1:\")) return true;\n  return false;\n}\n\n// Entrada n8n Cloud safe\nconst inItems = (typeof items !== \"undefined\" && Array.isArray(items)) ? items : $input.all();\nconst out = [];\n\nconst store = $getWorkflowStaticData(\"global\");\nif (!isObj(store.threads)) store.threads = {};\n\nfor (const it of inItems) {\n  const j = isObj(it.json) ? it.json : {};\n  const raw_text = getIncomingText(j);\n  const reply_text = getReplyText(j);\n  const chat_id = getChatId(j);\n\n  const routing_key = normStr((chat_id !== null && chat_id !== undefined) ? `tg:${chat_id}` : \"tg:unknown\");\n\n  if (!store.threads[routing_key]) {\n    store.threads[routing_key] = {\n      refinement_pass: 0,\n      last_state: \"\",\n      last_switch_key: \"\",\n      mode: \"alignment\",\n      user_email: \"\",\n      seed_alignment_idea: \"\",\n      last_alignment_idea: \"\",\n      last_approved_alignment_idea: \"\",\n      last_clarify_answers_text: \"\",\n      awaiting_clarify_answers: false,\n      last_alignment_gate: \"\",\n      last_alignment_score_total: 0,\n      last_alignment_power_questions: []\n    };\n  }\n  const thread = store.threads[routing_key];\n\n  let { intent, after_action, reset } = detectIntentAndAction(raw_text);\n\n  // body_text = mensaje sin l√≠neas de comandos\n  const body_text = stripCommandLines(raw_text);\n\n  // Base idea ‚Äúviva‚Äù (para AFTER LLM)\n  const aliveIdea = normStr(coalesce(\n    thread.last_approved_alignment_idea,\n    thread.last_alignment_idea,\n    thread.seed_alignment_idea,\n    j.last_alignment_idea,\n    j.seed_alignment_idea,\n    \"\"\n  ));\n\n  // Default\n  let _user_text = raw_text;\n\n  // ===============================\n  // PATCH 1: /after con body que SON respuestas (A1/A2...) -> NO contaminar idea\n  // - Antes: intent=after y body_text => _user_text=body_text (se iba con respuestas como si fuera idea)\n  // - Ahora: si body_text parece respuestas, lo tratamos como clarify_answers_text y mantenemos idea viva en _user_text\n  // ===============================\n  let captured_after_answers = \"\";\n  const isAfterCmd = (intent === \"after\" && (after_action === \"refine\" || after_action === \"brief\"));\n\n  if (isAfterCmd && body_text && looksLikeAnswers(body_text)) {\n    captured_after_answers = body_text;\n    _user_text = aliveIdea || body_text; // si no hay idea viva (caso raro), al menos no mandamos \"/after\"\n  } else {\n    // comportamiento anterior: /after con body (idea) => body es idea\n    if (intent === \"after\" && after_action && body_text) {\n      _user_text = body_text;\n    }\n  }\n\n  // ‚úÖ /continue con body => respuestas (para alignment clarify followup)\n  if (intent === \"alignment\" && after_action === \"continue\" && body_text) {\n    _user_text = body_text;\n    thread.last_clarify_answers_text = body_text;\n  }\n\n  // ‚úÖ /clarify con body => idea (para alignment)\n  if (intent === \"alignment\" && after_action === \"clarify\" && body_text) {\n    _user_text = body_text;\n  }\n\n  // ‚úÖ /after o /brief sin body -> idea persistida\n  const isCommandOnlyAfter = (intent === \"after\" && (after_action === \"refine\" || after_action === \"brief\") && !body_text);\n  if (isCommandOnlyAfter) {\n    _user_text = normStr(\n      coalesce(\n        thread.last_approved_alignment_idea,\n        thread.last_alignment_idea,\n        thread.seed_alignment_idea,\n        j.last_alignment_idea,\n        j.seed_alignment_idea,\n        reply_text,\n        \"\"\n      )\n    );\n  }\n\n  // Persistir respuestas de Clarify si ven√≠amos esperando respuestas y llegan en crudo\n  if (intent === \"alignment\" && thread.awaiting_clarify_answers && looksLikeAnswers(raw_text)) {\n    thread.last_clarify_answers_text = raw_text;\n  }\n\n  // ===============================\n  // PATCH 2: si estamos en modo AFTER y llegan respuestas sin comando -> route a AFTER (no alignment)\n  // - Evita que el usuario ‚Äúcaiga‚Äù al Alignment LLM por solo contestar A1/A2...\n  // ===============================\n  if (intent === \"alignment\" && !after_action && normLower(thread.mode) === \"after\" && looksLikeAnswers(raw_text)) {\n    intent = \"after\";\n    after_action = \"continue\";\n    captured_after_answers = raw_text;     // respuestas para AFTER LLM\n    _user_text = aliveIdea || raw_text;    // idea viva como input principal\n  }\n\n  // Se√±al robusta de follow-up para el LLM Alignment:\n  const is_clarify_followup =\n    (intent === \"alignment\" && after_action === \"continue\") ||\n    (intent === \"alignment\" && thread.awaiting_clarify_answers && looksLikeAnswers(raw_text));\n\n  const clarify_answers_text_alignment = normStr(coalesce(\n    (intent === \"alignment\" && after_action === \"continue\" && body_text) ? body_text : null,\n    thread.last_clarify_answers_text,\n    \"\"\n  ));\n\n  // AFTER answers (para AFTER LLM)\n  const clarify_answers_text_after = normStr(coalesce(\n    captured_after_answers,\n    \"\" // no heredamos thread.last_clarify_answers_text aqu√≠ para no mezclar con Alignment\n  ));\n\n  // Propagar contexto de thread al payload\n  const output = isObj(j.output) ? j.output : {};\n  output.chat_id = chat_id;\n  output._user_text = _user_text;\n  output.routing_key = routing_key;\n\n  output.intent = intent;\n  output.after_action = after_action;\n  output.reset = !!reset;\n\n  // ‚úÖ Idea viva expl√≠cita (para LLM AFTER / Post-Merge)\n  output.idea_text = aliveIdea || normStr(coalesce(output.idea_text, \"\"));\n\n  // Contexto persistido\n  output.seed_alignment_idea = thread.seed_alignment_idea || \"\";\n  output.last_alignment_idea = thread.last_alignment_idea || \"\";\n  output.last_approved_alignment_idea = thread.last_approved_alignment_idea || \"\";\n  output.last_clarify_answers_text = thread.last_clarify_answers_text || \"\";\n\n  // Alignment follow-up\n  output.is_clarify_followup = !!is_clarify_followup;\n  output.clarify_answers_text = (intent === \"alignment\") ? clarify_answers_text_alignment : clarify_answers_text_after;\n\n  output.thread_state = {\n    awaiting_clarify_answers: !!thread.awaiting_clarify_answers,\n    last_alignment_gate: normStr(thread.last_alignment_gate || \"\"),\n    last_alignment_score_total: Number(thread.last_alignment_score_total || 0),\n    last_alignment_power_questions: Array.isArray(thread.last_alignment_power_questions) ? thread.last_alignment_power_questions : [],\n    mode: normStr(thread.mode || \"\")\n  };\n\n  const top = { ...j };\n  top.chat_id = chat_id;\n  top._user_text = _user_text;\n  top.routing_key = routing_key;\n  top.intent = intent;\n  top.after_action = after_action;\n  top.reset = !!reset;\n  top.reply_text = reply_text;\n  top.output = output;\n\n  if (!isObj(output.chat)) output.chat = {};\n  if (!output.chat.id && chat_id !== null && chat_id !== undefined) output.chat.id = chat_id;\n\n  out.push({ json: top });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2816,
        2176
      ],
      "id": "3fe3943f-b948-4fac-a036-fcb56ee261f8",
      "name": "TG Pre-route Normalizer + Edits3"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Post-Merge Organizer + Switch Enricher ‚Äî v1.6.1 (LATCH + GREETING FIX)\n * FIX:\n * - Greeting: si intent===\"greeting\" => switch_key=\"greeting\" (sin depender de route/state).\n * - Latch de brief: captura intenci√≥n de brief desde:\n *    a) comando /briefejecutivo (Telegram real o fallback controlado), y tambi√©n\n *    b) intent=\"after\" + after_action=\"brief\" (porque TG v4.3 ya lo normaliza)\n * - Consume latch cuando brief_ready === true (desde thread o payload actual).\n * - Nunca lee next_user_instruction para rutear.\n * - Si NO hay comando ni latch aplicado, route se limpia (null) para evitar arrastre.\n */\n\nfunction coalesce(...args){ for (const v of args) if (v !== undefined && v !== null && v !== \"\") return v; return null; }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\nfunction normLower(s){ return normStr(s).toLowerCase(); }\nfunction normArr(a, max=12){ return Array.isArray(a) ? a.map(x=>normStr(x)).filter(Boolean).slice(0,max) : []; }\n\nfunction safeParseJSON(maybe){\n  if (isObj(maybe)) return maybe;\n  if (typeof maybe === \"string\"){\n    try { return JSON.parse(maybe); } catch(_){}\n    const s = maybe.indexOf(\"{\"), e = maybe.lastIndexOf(\"}\");\n    if (s >= 0 && e > s) { try { return JSON.parse(maybe.slice(s, e+1)); } catch(_){} }\n  }\n  return null;\n}\n\nfunction toNumScore(v, fallback=0){\n  if (typeof v === \"number\" && Number.isFinite(v)) return v;\n  if (typeof v === \"string\"){\n    const m = v.match(/-?\\d+(\\.\\d+)?/);\n    if (m) {\n      const n = Number(m[0]);\n      if (Number.isFinite(n)) return n;\n    }\n  }\n  return fallback;\n}\n\nfunction extractChatIdFromRoutingKey(rk){\n  const s = normStr(rk);\n  const m = s.match(/^tg:(\\d{3,})$/);\n  return m ? m[1] : null;\n}\n\nfunction extractTelegramChatId(j){\n  const cand = coalesce(\n    j.chat_id,\n    j.chatId,\n    j.context?.chat?.id,\n    j.context?.chat_id,\n    j.message?.chat?.id,\n    j.message?.chat_id,\n    j.callback_query?.message?.chat?.id,\n    j.update?.message?.chat?.id,\n    j.update?.callback_query?.message?.chat?.id,\n    j.data?.chat?.id,\n    j.data?.chat_id,\n    j.output?.chat_id // √∫ltimo recurso\n  );\n\n  if (typeof cand === \"number\" && Number.isFinite(cand)) return String(cand);\n  const s = normStr(cand);\n  if (s && /^\\d{3,}$/.test(s)) return s;\n\n  const rk = coalesce(j.routing_key, j.output?.routing_key, null);\n  const fromRK = extractChatIdFromRoutingKey(rk);\n  return fromRK || null;\n}\n\n/**\n * ‚úÖ SOLO texto real de Telegram (para comandos).\n */\nfunction extractUserCommandTextTelegramOnly(j){\n  return normStr(coalesce(\n    j.message?.text,\n    j.message?.caption,\n    j.update?.message?.text,\n    j.update?.message?.caption,\n    j.callback_query?.data,\n    j.update?.callback_query?.data,\n    \"\"\n  ));\n}\n\n/**\n * ‚úÖ Fallback controlado: si NO hay Telegram fields,\n * usamos _user_text SOLO si empieza con \"/\".\n * Esto evita auto-disparo por \"Escribe /briefejecutivo\".\n */\nfunction extractUserCommandText(j){\n  const tgram = extractUserCommandTextTelegramOnly(j);\n  if (tgram) return tgram;\n\n  const shadow = normStr(coalesce(\n    j._user_text,\n    j.text,\n    j.output?._user_text,\n    j.context?._user_text,\n    \"\"\n  ));\n\n  if (/^\\//.test(shadow) && shadow.length <= 60) return shadow; // solo comandos cortos\n  return \"\";\n}\n\n/**\n * Texto general (para envelope), puede caer en output.*\n */\nfunction extractTelegramTextLoose(j){\n  return normStr(coalesce(\n    extractUserCommandTextTelegramOnly(j),\n    j._user_text,\n    j.output?._user_text,\n    j.output?.text,\n    \"\"\n  ));\n}\n\nfunction extractLLMPayload(j){\n  if (!isObj(j)) return null;\n\n  // Caso 1: ya viene envelope con state/gate\n  if (isObj(j.output) && (j.output.state || j.output.gate)) return j.output;\n\n  // Caso 2: viene \"output\" con campos AFTER (sin state)\n  if (isObj(j.output)) {\n    const o = j.output;\n    const looksAfter =\n      typeof o.feature_title === \"string\" ||\n      typeof o.executive_summary === \"string\" ||\n      Array.isArray(o.readiness_criteria_min) ||\n      Array.isArray(o.checkpoints_obligatorios) ||\n      Array.isArray(o.sprint_plan) ||\n      Array.isArray(o.user_stories) ||\n      typeof o.brief_ready === \"boolean\" ||\n      isObj(o.brief);\n\n    if (looksAfter) return o;\n  }\n\n  // Caso 3: payload directo\n  if (j.state || j.gate) return j;\n\n  // Caso 4: OpenAI chat completion\n  const content = j?.choices?.[0]?.message?.content;\n  if (content){\n    const parsed = safeParseJSON(content);\n    if (parsed) return parsed.output ? parsed.output : parsed;\n  }\n\n  // Caso 5: wrappers varios\n  const maybe = coalesce(j.data, j.result, j.response, j.message, null);\n  const parsed2 = safeParseJSON(maybe);\n  if (parsed2) return parsed2.output ? parsed2.output : parsed2;\n\n  return null;\n}\n\nfunction computeSwitchKey(finalOut){\n  const gate = normStr(finalOut.gate || \"\");\n  const state = normStr(finalOut.state || \"\");\n  const route = normStr(finalOut.route || \"\");\n  const intent = normStr(finalOut.intent || \"\");\n\n  // ‚úÖ FIX GREETING: prioriza intent\n  if (intent === \"greeting\") return \"greeting\";\n\n  if (route === \"brief.ejecutivo\") return \"brief.ejecutivo\";\n  if (route === \"greeting\") return \"greeting\";\n\n  if (gate === \"after_refine\") return \"alignment.after_refine\";\n  if (gate === \"clarify\") return \"alignment.clarify\";\n  if (gate === \"discard\") return \"alignment.discard\";\n  if (gate) return \"alignment.unknown_gate\";\n\n  if (state === \"after_refinement\") return \"after.after_refinement\";\n  if (state === \"after_brief\") return \"after.after_brief\";\n\n  if (state === \"error\") return \"error\";\n  return \"fallback\";\n}\n\nfunction buildFinalEnvelope(j, ap){\n  let chat_id = coalesce(\n    extractTelegramChatId(j),\n    ap?.chat_id,\n    ap?.output?.chat_id,\n    j.output?.thread_state?.last_chat_id,\n    j.thread_state?.last_chat_id,\n    null\n  );\n\n  const rawUserText = extractTelegramTextLoose(j);\n\n  const idea_text = normStr(coalesce(\n    ap?.idea_text,\n    ap?.output?.idea_text,\n    j.output?.idea_text,\n    j.idea_text,\n    \"\"\n  ));\n\n  const _user_text = normStr(coalesce(\n    rawUserText,\n    idea_text,\n    ap?._user_text,\n    ap?.output?._user_text,\n    \"\"\n  ));\n\n  const routing_key = chat_id ? `tg:${chat_id}` : normStr(coalesce(j.routing_key, j.output?.routing_key, \"tg:unknown\"));\n\n  // ‚úÖ Usamos intent/after_action normalizados (vienen de tu TG v4.3)\n  const intent = normLower(coalesce(j.intent, j.output?.intent, \"\"));\n  const after_action = normLower(coalesce(j.after_action, j.output?.after_action, \"\"));\n\n  // ‚ö†Ô∏è NO heredamos route de output.* para evitar arrastre.\n  // route se decide por comando o latch.\n  const route = coalesce(j.route, null);\n\n  const _reset = !!coalesce(j.output?._reset, j._reset, j.output?.reset, j.reset, false);\n\n  return {\n    chat_id,\n    _user_text,\n    idea_text,\n    routing_key,\n    intent: intent || null,\n    after_action: after_action || null,\n    route,\n    _reset,\n\n    state: null,\n    gate: null,\n    alignment: null,\n    after_result: null,\n    brief: null,\n    error_message: \"\"\n  };\n}\n\nfunction readyFromPayload(j, ap){\n  return (\n    ap?.brief_ready === true ||\n    j?.output?.after_result?.brief_ready === true ||\n    j?.output?.brief_ready === true\n  );\n}\n\nconst store = $getWorkflowStaticData(\"global\");\nif (!isObj(store.threads)) store.threads = {};\n\nconst out = [];\nconst inItems = (typeof items !== \"undefined\" && Array.isArray(items)) ? items : $input.all();\n\nfor (const it of inItems){\n  const j = isObj(it.json) ? it.json : {};\n  const ap = extractLLMPayload(j);\n  const finalOut = buildFinalEnvelope(j, ap);\n\n  const rk = finalOut.chat_id ? `tg:${finalOut.chat_id}` : (finalOut.routing_key || \"tg:unknown\");\n  finalOut.routing_key = rk;\n\n  if (!store.threads[rk]) {\n    store.threads[rk] = {\n      refinement_pass: 0, last_state: \"\", last_switch_key: \"\", mode: \"alignment\", user_email: \"\",\n      seed_alignment_idea: \"\",\n      last_alignment_idea: \"\",\n      last_approved_alignment_idea: \"\",\n      last_clarify_answers_text: \"\",\n      awaiting_clarify_answers: false,\n      last_alignment_gate: \"\",\n      last_alignment_score_total: 0,\n      last_alignment_power_questions: [],\n      last_after_brief_ready: false,\n      last_chat_id: finalOut.chat_id ? String(finalOut.chat_id) : \"\",\n      pending_brief_request: false\n    };\n  }\n\n  const thread = store.threads[rk];\n  if (finalOut.chat_id) thread.last_chat_id = String(finalOut.chat_id);\n\n  const userCmdText = normStr(extractUserCommandText(j));\n  const t = normLower(userCmdText);\n\n  // -------------------------------\n  // ‚úÖ GREETING HARD PATH (no fallback)\n  // -------------------------------\n  if (finalOut.intent === \"greeting\") {\n    // no arrastre de route: lo marcamos expl√≠cito\n    finalOut.route = \"greeting\";\n    finalOut.state = \"greeting\";\n    finalOut.switch_key = \"greeting\";\n\n    thread.last_switch_key = \"greeting\";\n    thread.last_state = \"greeting\";\n\n    finalOut.thread_state = { routing_key: rk, ...thread };\n    out.push({ json: { output: finalOut } });\n    continue;\n  }\n\n  // Reset\n  const wantsReset = finalOut._reset || t === \"/reset\" || t.startsWith(\"/reset \");\n  if (wantsReset) {\n    store.threads[rk] = {\n      refinement_pass: 0, last_state: \"\", last_switch_key: \"\", mode: \"alignment\", user_email: \"\",\n      seed_alignment_idea: \"\", last_alignment_idea: \"\", last_approved_alignment_idea: \"\",\n      last_clarify_answers_text: \"\", awaiting_clarify_answers: false,\n      last_alignment_gate: \"\", last_alignment_score_total: 0, last_alignment_power_questions: [],\n      last_after_brief_ready: false,\n      last_chat_id: thread.last_chat_id || \"\",\n      pending_brief_request: false\n    };\n\n    finalOut.route = \"greeting\";\n    finalOut.intent = \"greeting\";\n    finalOut.after_action = null;\n\n    finalOut.state = \"greeting\";\n    finalOut.switch_key = \"greeting\";\n    finalOut.thread_state = { routing_key: rk, ...store.threads[rk] };\n    out.push({ json: { output: finalOut } });\n    continue;\n  }\n\n  // -------------------------------\n  // 1) LATCH: capturar intenci√≥n de BRIEF\n  //    a) comando /briefejecutivo\n  //    b) intent after + after_action brief (viene de TG v4.3)\n  // -------------------------------\n  const isBriefCmdText = /^\\/briefejecutivo(\\s|@|$)/i.test(userCmdText);\n  const isBriefByNormalized = (finalOut.intent === \"after\" && finalOut.after_action === \"brief\");\n\n  if (isBriefCmdText || isBriefByNormalized) {\n    thread.pending_brief_request = true;\n\n    const readyFromThread = (thread.last_after_brief_ready === true);\n    const readyNow = readyFromThread || readyFromPayload(j, ap);\n\n    if (readyNow) {\n      finalOut.route = \"brief.ejecutivo\";\n      finalOut.state = \"after_brief\";\n      finalOut.switch_key = \"brief.ejecutivo\";\n      thread.pending_brief_request = false;\n    } else {\n      // A√∫n no listo: se queda en after.after_brief\n      finalOut.route = null;\n      finalOut.state = \"after_brief\";\n      finalOut.switch_key = \"after.after_brief\";\n    }\n\n    thread.last_switch_key = String(finalOut.switch_key || \"\");\n    thread.last_state = String(finalOut.state || \"\");\n\n    finalOut.thread_state = { routing_key: rk, ...thread };\n    out.push({ json: { output: finalOut } });\n    continue;\n  }\n\n  // ‚úÖ si no hay comando, route SIEMPRE null (evita arrastre)\n  finalOut.route = null;\n\n  // fallback chat_id\n  if (!finalOut.chat_id && thread.last_chat_id){\n    finalOut.chat_id = String(thread.last_chat_id);\n    finalOut.routing_key = `tg:${finalOut.chat_id}`;\n  }\n\n  if (!finalOut.chat_id){\n    finalOut.state = \"error\";\n    finalOut.error_message = \"Falta chat_id. No puedo responder por Telegram.\";\n    finalOut.switch_key = \"error\";\n  } else {\n\n    // -------------------------------\n    // 2) Procesar payload (AFTER / Alignment)\n    // -------------------------------\n    if (ap){\n      let apState = normStr(ap.state || \"\");\n\n      // Derivar state si no viene, pero el payload parece AFTER\n      if (!apState) {\n        const looksAfter =\n          typeof ap.feature_title === \"string\" ||\n          typeof ap.executive_summary === \"string\" ||\n          Array.isArray(ap.sprint_plan) ||\n          Array.isArray(ap.user_stories) ||\n          typeof ap.brief_ready === \"boolean\" ||\n          isObj(ap.brief);\n\n        if (looksAfter) apState = (ap.brief_ready === true) ? \"after_brief\" : \"after_refinement\";\n      }\n\n      if (apState === \"after_refinement\" || apState === \"after_brief\") {\n        finalOut.state = apState;\n\n        finalOut.after_result = {\n          feature_title: normStr(coalesce(ap.feature_title, \"\")),\n          idea_text: normStr(coalesce(ap.idea_text, finalOut.idea_text, \"\")),\n          brief_ready: !!coalesce(ap.brief_ready, (apState === \"after_brief\"), false),\n          executive_summary: normStr(coalesce(ap.executive_summary, \"\")),\n          readiness_criteria_min: normArr(ap.readiness_criteria_min, 12),\n          checkpoints_obligatorios: normArr(ap.checkpoints_obligatorios, 12),\n          gaps_blocking_ready: Array.isArray(ap.gaps_blocking_ready) ? normArr(ap.gaps_blocking_ready, 12) : [],\n          key_dependencies: normArr(ap.key_dependencies, 12),\n          key_risks: normArr(ap.key_risks, 12),\n          recommended_kpis: normArr(ap.recommended_kpis, 12),\n          questions: Array.isArray(ap.questions) ? ap.questions : [],\n          macro_estimation_hours_total_range: ap.macro_estimation_hours_total_range || null,\n          sprint_plan: Array.isArray(ap.sprint_plan) ? ap.sprint_plan : [],\n          user_stories: Array.isArray(ap.user_stories) ? ap.user_stories : [],\n          next_user_instruction: normStr(coalesce(ap.next_user_instruction, \"\"))\n        };\n\n        // persist readiness\n        thread.last_after_brief_ready = !!finalOut.after_result.brief_ready;\n\n        if (apState === \"after_brief\") finalOut.brief = ap.brief || ap.brief_ejecutivo || null;\n\n        const afterIdea = normStr(coalesce(ap.idea_text, finalOut.idea_text, ap._user_text, \"\"));\n        if (afterIdea) {\n          thread.last_alignment_idea = afterIdea;\n          if (!thread.seed_alignment_idea) thread.seed_alignment_idea = afterIdea;\n        }\n\n      } else {\n        // Alignment / gates\n        const scoreCandidate = coalesce(ap.score_total, ap.scoreTotal, ap.score, ap.total_score, null);\n        const looksAlignment = (\n          ap.gate ||\n          ap.state === \"alignment_result\" ||\n          scoreCandidate !== null ||\n          ap.rationale !== undefined ||\n          Array.isArray(ap.power_questions)\n        );\n\n        if (looksAlignment){\n          finalOut.state = \"alignment_result\";\n          finalOut.gate = ap.gate ? normStr(ap.gate) : null;\n          finalOut.alignment = ap;\n\n          const idea = normStr(coalesce(ap.idea_text, ap._user_text, \"\"));\n          if (idea) {\n            thread.last_alignment_idea = idea;\n            if (!thread.seed_alignment_idea) thread.seed_alignment_idea = idea;\n          }\n\n          thread.last_alignment_gate = normStr(ap.gate || \"\");\n          thread.last_alignment_score_total = toNumScore(scoreCandidate, 0);\n          thread.last_alignment_power_questions = Array.isArray(ap.power_questions) ? ap.power_questions : [];\n          thread.awaiting_clarify_answers = (ap.gate === \"clarify\");\n\n          if (ap.gate === \"after_refine\" && idea) thread.last_approved_alignment_idea = idea;\n\n        } else if (ap.state === \"error\"){\n          finalOut.state = \"error\";\n          finalOut.error_message = normStr(ap.error_message || \"Error no especificado del agente.\");\n        }\n      }\n    }\n\n    // -------------------------------\n    // 3) LATCH: si ya pidieron brief antes y ahora est√° READY, enrutar\n    // -------------------------------\n    if (thread.pending_brief_request === true) {\n      const readyFromThread = (thread.last_after_brief_ready === true);\n      const readyNow = readyFromThread || readyFromPayload(j, ap);\n\n      if (readyNow) {\n        finalOut.route = \"brief.ejecutivo\";\n        finalOut.state = finalOut.state || \"after_brief\";\n        finalOut.switch_key = \"brief.ejecutivo\";\n        thread.pending_brief_request = false;\n      }\n    }\n\n    // si no seteamos switch_key arriba, computar normalmente\n    if (!finalOut.switch_key) finalOut.switch_key = computeSwitchKey(finalOut);\n  }\n\n  thread.last_switch_key = String(finalOut.switch_key || \"\");\n  thread.last_state = String(finalOut.state || \"\");\n\n  finalOut.thread_state = {\n    routing_key: rk,\n    refinement_pass: Number(thread.refinement_pass || 0),\n    last_state: normStr(thread.last_state || \"\"),\n    last_switch_key: normStr(thread.last_switch_key || \"\"),\n    mode: normStr(thread.mode || \"\"),\n    user_email: normStr(thread.user_email || \"\"),\n    seed_alignment_idea: normStr(thread.seed_alignment_idea || \"\"),\n    last_alignment_idea: normStr(thread.last_alignment_idea || \"\"),\n    last_approved_alignment_idea: normStr(thread.last_approved_alignment_idea || \"\"),\n    last_clarify_answers_text: normStr(thread.last_clarify_answers_text || \"\"),\n    awaiting_clarify_answers: !!thread.awaiting_clarify_answers,\n    last_alignment_gate: normStr(thread.last_alignment_gate || \"\"),\n    last_alignment_score_total: Number.isFinite(thread.last_alignment_score_total) ? thread.last_alignment_score_total : 0,\n    last_alignment_power_questions: Array.isArray(thread.last_alignment_power_questions) ? thread.last_alignment_power_questions : [],\n    last_after_brief_ready: (thread.last_after_brief_ready === true),\n    last_chat_id: normStr(thread.last_chat_id || \"\"),\n    pending_brief_request: (thread.pending_brief_request === true)\n  };\n\n  out.push({ json: { output: finalOut } });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -848,
        2064
      ],
      "id": "beb9112c-9fa1-4016-aaea-a0490d1485f2",
      "name": "Post-Merge Organizer + Switch Enricher1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Mensaje (IDEA): {{ $json.output._user_text }}\nClarify aprobado (si existe): {{ $json.output?.last_clarify_answers_text ?? $json.last_clarify_answers_text ?? $json.output?.thread_state?.last_clarify_answers_text ?? \"\" }}\nChat id: {{ $json.chat_id }}\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Eres el Alignment Engine de AfterBot.\n\nTu trabajo:\n1) Evaluar ideas/proyectos/features con MCDA explicable.\n2) Decidir gate:\n   - after_refine (score_total >= 80)\n   - clarify (60‚Äì79) con preguntas retadoras\n   - discard (<60) con un reto claro para replantear\n\nEstilo: ejecutivo, exigente, orientado a evidencia.\nRegla cr√≠tica: NO inventes datos. Si faltan, decl√°ralos como assumptions y pide evidencia m√≠nima.\nSalida: SOLO JSON v√°lido, sin markdown ni texto extra.\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n0) Regla de conversaci√≥n (NO tratar follow-up como idea nueva)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nVas a recibir dos tipos de inputs:\n\nA) Idea inicial:\n- Texto describe una idea/proyecto/feature.\n\nB) Follow-up de Clarify (respuestas a tus power_questions):\n- El texto viene como respuestas tipo \"A1: ... A2: ...\", o\n- El payload incluye se√±ales como:\n  - is_clarify_followup=true\n  - clarify_answers_text\n  - thread.last_alignment_idea / last_alignment_idea / seed_alignment_idea\n  - last_power_questions / last_clarify_questions\n\nREGLA OBLIGATORIA:\n- Si detectas follow-up, DEBES usar como base la idea original y NO reemplazarla por las respuestas.\n- Recalculas scores y gate usando: idea base + respuestas.\n\nCampo clave de salida:\n- idea_text: SIEMPRE debe contener la idea base usada para la evaluaci√≥n.\n  - Si es follow-up: idea_text = idea original (thread.last_alignment_idea o last_alignment_idea o seed_alignment_idea).\n  - Si es idea inicial: idea_text = el texto de la idea.\n  - Si parece follow-up pero NO hay idea original disponible: idea_text = \"\" y gate=\"clarify\" pidiendo que peguen la idea original.\n\nNota: _user_text debe ser el texto entrante (puede ser A1/A2 en follow-up). NO lo uses como sustituto de idea_text.\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nA) Director Profile\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDIRECTOR_PROFILE (CoE Transformaci√≥n Digital y Agilidad):\nVision:\n\nPosicionar al CoE como referente Telco ‚Äúdata-driven‚Äù en digitalizaci√≥n e inteligencia artificial: visibilizar capacidades e integrantes, empoderar ejecuci√≥n y acelerar captura de valor.\n\nReorganizar los frentes de trabajo bajo una visi√≥n que fortalezca el modelo ‚ÄúTelcoSuperLigera‚Äù, priorizando impacto en 4 categor√≠as: digitalizaci√≥n orientada al cliente, innovaci√≥n tecnol√≥gica, nuevas formas de trabajar y digitalizaci√≥n de funciones de soporte.\n\nEvolucionar el CoE con base en IA como palanca transversal en 5 dimensiones de cambio: estrategia, estructura, procesos, personas y tecnolog√≠a.\n\nExpectativas:\n\nEvidencia y valor en corto plazo: prototipos/MVPs y casos de uso con beneficio cuantificado; lo que no tenga m√©trica/umbral, no entra al portafolio.\n\nGobierno y ejecuci√≥n ‚Äúde verdad‚Äù: hoja de ruta E2E, responsables claros, y despliegue/ adopci√≥n tan importantes como construir.\n\nSimplificaci√≥n antes que complejidad: leanificaci√≥n, reducci√≥n de fricci√≥n y documentaci√≥n, y estandarizaci√≥n para escalar.\n\nIA con cumplimiento: dise√±o seguro, trazable y alineado a pol√≠ticas de seguridad y cumplimiento en soluciones de IA.\n\nDiplomacia con exigencia: alinear m√∫ltiples stakeholders y √°reas, pero sostener la barra alta de resultados y accountability.\n\nFoco:\n\nCaptura de beneficios ($) por digitalizaci√≥n: ingresos adicionales y optimizaci√≥n de costos.\n\nPortafolio de IA y agentes: identificar oportunidades, priorizar por valor y escalar a producci√≥n con adopci√≥n.\n\nRedise√±o E2E de procesos cr√≠ticos: To-Be, modelo operativo, m√©tricas y performance.\n\nCultura y capacidades: agilidad, innovaci√≥n y talento (formaci√≥n y despliegue por roles).\n\nFundamentos organizacionales: fortalecer estrategia, estructura, procesos, personas y tecnolog√≠a como palancas integradas.\n\nOKRs (1Q 2026):\n\n(Obj 1) Ser referentes en digitalizaci√≥n e IA, generando eficiencias y nuevas fuentes de ingreso:\n\n1A. Capturar $5.200M en beneficios de digitalizaci√≥n mediante nuevas tecnolog√≠as en proyectos internos.\n\n1B. Identificar $3.000M y capturar $1.500M en beneficios por casos de uso de IA.\n\n1C. Implementar 22 agentes de IA, logrando que al menos el 10% genere rentabilidad y eficiencia para el negocio.\n\n1D. Dise√±ar hoja de ruta para 2 procesos que deban redefinirse E2E con IA y tengan impacto en negocio.\n\n(Obj 2) Simplificar y optimizar procesos de negocio para una telco m√°s ligera y eficiente:\n\n2A. Capturar $500M v√≠a leanificaci√≥n y simplificaci√≥n, implementando 3 iniciativas de mejora.\n\n2B. Implementar modelo operativo de procesos en 3 E2E, completando 16 de 23 procesos priorizados y reduciendo 30% la documentaci√≥n actual.\n\n2C. Mejorar 10% el desempe√±o promedio de 1 proceso cr√≠tico por segmento.\n\n2D. Dise√±ar el primer blueprint y programa de implementaci√≥n con visi√≥n IA para la organizaci√≥n.\n\n(Obj 3) Acelerar cultura digital, innovaci√≥n y capacidades √°giles:\n\n3A. Asegurar el proyecto CCDD para flujos priorizados (Terminales y Fibra) logrando 100% de la PDC.\n\n3B. Cocrear un nuevo modelo de cultura organizacional integrando innovaci√≥n, liderazgo √°gil, Lean y aprendizaje √°gil (participaci√≥n ‚â• X colaboradores; pendiente definir X).\n\n3C. Convertir 30% de prototipos en MVPs y escalar 10% de POC/Piloto a implementaci√≥n en el negocio.\n\n3D. Activar 100% de los planes de acci√≥n definidos en 2025 para SM, PO y AT, asegurando alineaci√≥n al performance corporativo.\n\nCarrera (resumen ejecutivo):\n\nHead of Digital Transformation (Telef√≥nica, Colombia): due√±a de agenda de transformaci√≥n y captura de beneficios desde 2019 (rol sostenido, ejecuci√≥n a escala).\n\nEx-MinHacienda (Direcci√≥n de Empresas Estatales): experiencia en gobierno corporativo, seguimiento de desempe√±o y articulaci√≥n con sectores regulados (energ√≠a/utilities y financiero).\n\nBase ‚Äúfinance-first‚Äù en mercado de capitales y asesor√≠a: Investor Relations / Investment Banking Advisor (MinHacienda), Financial Management (Ernst & Young) y certificaci√≥n/informaci√≥n en AMV (autorregulador).\n\nFormaci√≥n que habilita el rol ‚Äústrategy-to-execution‚Äù: MBA (University of Sheffield) + Maestr√≠a en Finanzas (Uniandes) + programas ejecutivos en transformaci√≥n digital (Uniandes/ESIC).\n\nPersona:\n\nL√≠der ‚Äúdiplom√°tica con filo‚Äù: sabe alinear intereses (telco + gobierno + regulatorio), pero conduce con exigencia de resultados y gobernanza; evita ambig√ºedad en responsables y m√©tricas. (Inferencia por trayectoria p√∫blica/privada y rol actual).\n\nEnfoque ‚Äúbeneficios primero‚Äù: viene de finanzas/banca de inversi√≥n; tiende a priorizar casos con business case, captura medible y control de ejecuci√≥n (no solo actividad).\n\nCredenciales que refuerzan el estilo: certificaci√≥n ‚ÄúDigital Transformation: From Strategy to Execution‚Äù y formaci√≥n en seguridad/cumplimiento para soluciones de IA (sesgo a IA responsable y desplegable).\n\nComunicaci√≥n ejecutiva y multistakeholder: triling√ºe (ES/EN/FR), √∫til para relacionamiento y benchmarking; orientada a reputaci√≥n del CoE como referente. \n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nB) Marco de evaluaci√≥n (MCDA explicable)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCalifica 8 criterios (0‚Äì100) y calcula score_total (0‚Äì100) usando ponderaciones.\n\nCriterios:\n1) impacto_estrategico\n2) alineacion_vision_director\n3) viabilidad\n4) complejidad (inversa: m√°s complejidad => menor score)\n5) prototipado_time_to_market\n6) costos_dependencias\n7) probabilidad_exito_benchmark\n8) disrupcion\n\nPonderaciones base (suma 100):\n- impacto_estrategico: 20\n- alineacion_vision_director: 15\n- viabilidad: 15\n- complejidad: 10\n- prototipado_time_to_market: 10\n- costos_dependencias: 10\n- probabilidad_exito_benchmark: 10\n- disrupcion: 10\n\nAjuste permitido SOLO si DIRECTOR_PROFILE lo empuja claramente:\n- mueve m√°ximo ¬±5 por criterio\n- total=100\n- explica el porqu√© (una frase por ajuste)\n\nReglas anti-invenci√≥n:\n- Si no hay evidencia comparable, probabilidad_exito_benchmark conservador + declara evidencia faltante.\n- Si faltan datos cr√≠ticos, convi√©rtelos en assumptions y power_questions.\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nC) Gate rules + handoff a AFTER\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n- score_total >= 80 ‚Üí gate=\"after_refine\"\n- 60 <= score_total < 80 ‚Üí gate=\"clarify\"\n- score_total < 60 ‚Üí gate=\"discard\"\n\nSi gate=\"clarify\": 4‚Äì6 power_questions.\nSi gate=\"discard\": reto claro en next_prompt_for_after.\n\nHandoff:\n- Si gate=\"after_refine\": recommended_after_state=\"after_refinement\"\n- min_refinement_passes: 1 o 2 si alta dependencia/operaci√≥n compleja\n- readiness_criteria_min: m√≠nimo que AFTER debe validar antes de brief\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nD) Output JSON obligatorio\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDevuelve EXACTAMENTE este esquema (solo JSON):\n\n{\n  \"chat_id\": \"\",\n  \"_user_text\": \"\",\n  \"idea_text\": \"\",\n  \"state\": \"alignment_result\",\n  \"gate\": \"after_refine|clarify|discard\",\n  \"score_total\": 0,\n  \"weights_used\": { ... },\n  \"scores\": { ... },\n  \"rationale\": { ... },\n  \"assumptions\": [],\n  \"key_dependencies\": [],\n  \"key_risks\": [],\n  \"recommended_kpis\": [],\n  \"power_questions\": [],\n  \"next_prompt_for_after\": \"\",\n  \"handoff\": {\n    \"recommended_after_state\": \"after_refinement\",\n    \"min_refinement_passes\": 1,\n    \"readiness_criteria_min\": []\n  }\n}\n",
          "returnIntermediateSteps": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1808,
        1440
      ],
      "id": "48b266bc-deda-464c-aa67-dee34dd05dc6",
      "name": "LLM Alignment Engine AGILIDAD"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Mensaje: {{ $json.output._user_text }}\nChat id: {{ $json.message.from.id }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "Eres el AFTER Engine de AfterBot\n\nObjetivo:\nTransformar una idea ya evaluada (alignment) en un plan de refinamiento ACCIONABLE y verificable:\n- criterios m√≠nimos de READY\n- puntos de control obligatorios\n- gaps que bloquean READY\n- dependencias y riesgos\n- KPIs recomendados (con umbrales/definici√≥n operable)\n- plan por sprints (SP00..SP02 m√≠nimo)\n- macro-estimaci√≥n (rango total de horas)\n- preguntas concretas (A1..Ax) para cerrar faltantes\n- instrucci√≥n clara al usuario para el siguiente comando\n- (NUEVO) cierre de calificaci√≥n del Brief (Roles, Procesos, Estrategia, Cliente, Tecnologia) con score 1‚Äì5 y estrellas\n\nEntradas t√≠picas (pueden venir o no todas):\n- chat_id\n- idea_text (idea base, NO debe contaminarse con comandos ni respuestas)\n- _user_text (texto actual del usuario; puede ser idea, respuestas A1..Ax o ajustes)\n- alignment_result (gate, score_total, scores, rationale) [si viene]\n- clarify_answers_text (si el usuario respondi√≥ A1/A2...) [si viene]\n- after_action: refine | continue | brief\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nA) Director Profile\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nDIRECTOR_PROFILE (CoE Transformaci√≥n Digital y Agilidad):\nVision:\n\nPosicionar al CoE como referente Telco ‚Äúdata-driven‚Äù en digitalizaci√≥n e inteligencia artificial: visibilizar capacidades e integrantes, empoderar ejecuci√≥n y acelerar captura de valor.\n\nReorganizar los frentes de trabajo bajo una visi√≥n que fortalezca el modelo ‚ÄúTelcoSuperLigera‚Äù, priorizando impacto en 4 categor√≠as: digitalizaci√≥n orientada al cliente, innovaci√≥n tecnol√≥gica, nuevas formas de trabajar y digitalizaci√≥n de funciones de soporte.\n\nEvolucionar el CoE con base en IA como palanca transversal en 5 dimensiones de cambio: estrategia, estructura, procesos, personas y tecnolog√≠a.\n\nExpectativas:\n\nEvidencia y valor en corto plazo: prototipos/MVPs y casos de uso con beneficio cuantificado; lo que no tenga m√©trica/umbral, no entra al portafolio.\n\nGobierno y ejecuci√≥n ‚Äúde verdad‚Äù: hoja de ruta E2E, responsables claros, y despliegue/ adopci√≥n tan importantes como construir.\n\nSimplificaci√≥n antes que complejidad: leanificaci√≥n, reducci√≥n de fricci√≥n y documentaci√≥n, y estandarizaci√≥n para escalar.\n\nIA con cumplimiento: dise√±o seguro, trazable y alineado a pol√≠ticas de seguridad y cumplimiento en soluciones de IA.\n\nDiplomacia con exigencia: alinear m√∫ltiples stakeholders y √°reas, pero sostener la barra alta de resultados y accountability.\n\nFoco:\n\nCaptura de beneficios ($) por digitalizaci√≥n: ingresos adicionales y optimizaci√≥n de costos.\n\nPortafolio de IA y agentes: identificar oportunidades, priorizar por valor y escalar a producci√≥n con adopci√≥n.\n\nRedise√±o E2E de procesos cr√≠ticos: To-Be, modelo operativo, m√©tricas y performance.\n\nCultura y capacidades: agilidad, innovaci√≥n y talento (formaci√≥n y despliegue por roles).\n\nFundamentos organizacionales: fortalecer estrategia, estructura, procesos, personas y tecnolog√≠a como palancas integradas.\n\nOKRs (1Q 2026):\n\n(Obj 1) Ser referentes en digitalizaci√≥n e IA, generando eficiencias y nuevas fuentes de ingreso:\n\n1A. Capturar $5.200M en beneficios de digitalizaci√≥n mediante nuevas tecnolog√≠as en proyectos internos.\n\n1B. Identificar $3.000M y capturar $1.500M en beneficios por casos de uso de IA.\n\n1C. Implementar 22 agentes de IA, logrando que al menos el 10% genere rentabilidad y eficiencia para el negocio.\n\n1D. Dise√±ar hoja de ruta para 2 procesos que deban redefinirse E2E con IA y tengan impacto en negocio.\n\n(Obj 2) Simplificar y optimizar procesos de negocio para una telco m√°s ligera y eficiente:\n\n2A. Capturar $500M v√≠a leanificaci√≥n y simplificaci√≥n, implementando 3 iniciativas de mejora.\n\n2B. Implementar modelo operativo de procesos en 3 E2E, completando 16 de 23 procesos priorizados y reduciendo 30% la documentaci√≥n actual.\n\n2C. Mejorar 10% el desempe√±o promedio de 1 proceso cr√≠tico por segmento.\n\n2D. Dise√±ar el primer blueprint y programa de implementaci√≥n con visi√≥n IA para la organizaci√≥n.\n\n(Obj 3) Acelerar cultura digital, innovaci√≥n y capacidades √°giles:\n\n3A. Asegurar el proyecto CCDD para flujos priorizados (Terminales y Fibra) logrando 100% de la PDC.\n\n3B. Cocrear un nuevo modelo de cultura organizacional integrando innovaci√≥n, liderazgo √°gil, Lean y aprendizaje √°gil (participaci√≥n ‚â• X colaboradores; pendiente definir X).\n\n3C. Convertir 30% de prototipos en MVPs y escalar 10% de POC/Piloto a implementaci√≥n en el negocio.\n\n3D. Activar 100% de los planes de acci√≥n definidos en 2025 para SM, PO y AT, asegurando alineaci√≥n al performance corporativo.\n\nCarrera (resumen ejecutivo):\n\nHead of Digital Transformation (Telef√≥nica, Colombia): due√±a de agenda de transformaci√≥n y captura de beneficios desde 2019 (rol sostenido, ejecuci√≥n a escala).\n\nEx-MinHacienda (Direcci√≥n de Empresas Estatales): experiencia en gobierno corporativo, seguimiento de desempe√±o y articulaci√≥n con sectores regulados (energ√≠a/utilities y financiero).\n\nBase ‚Äúfinance-first‚Äù en mercado de capitales y asesor√≠a: Investor Relations / Investment Banking Advisor (MinHacienda), Financial Management (Ernst & Young) y certificaci√≥n/informaci√≥n en AMV (autorregulador).\n\nFormaci√≥n que habilita el rol ‚Äústrategy-to-execution‚Äù: MBA (University of Sheffield) + Maestr√≠a en Finanzas (Uniandes) + programas ejecutivos en transformaci√≥n digital (Uniandes/ESIC).\n\nPersona:\n\nL√≠der ‚Äúdiplom√°tica con filo‚Äù: sabe alinear intereses (telco + gobierno + regulatorio), pero conduce con exigencia de resultados y gobernanza; evita ambig√ºedad en responsables y m√©tricas. (Inferencia por trayectoria p√∫blica/privada y rol actual).\n\nEnfoque ‚Äúbeneficios primero‚Äù: viene de finanzas/banca de inversi√≥n; tiende a priorizar casos con business case, captura medible y control de ejecuci√≥n (no solo actividad).\n\nCredenciales que refuerzan el estilo: certificaci√≥n ‚ÄúDigital Transformation: From Strategy to Execution‚Äù y formaci√≥n en seguridad/cumplimiento para soluciones de IA (sesgo a IA responsable y desplegable).\n\nComunicaci√≥n ejecutiva y multistakeholder: triling√ºe (ES/EN/FR), √∫til para relacionamiento y benchmarking; orientada a reputaci√≥n del CoE como referente. \n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nB) Reglas cr√≠ticas (anti-vac√≠os)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n1) PROHIBIDO usar textos ‚Äúpendiente‚Äù, ‚Äúno disponible‚Äù, ‚Äúno informado‚Äù o listas vac√≠as como salida final.\n2) Si falta informaci√≥n, NO inventes datos. En su lugar:\n   - declara assumptions (m√°x 10) como gaps_blocking_ready\n   - genera questions espec√≠ficas (m√≠n 3, m√°x 8) pidiendo owner/fecha/umbral/evidencia.\n3) Debes producir SIEMPRE (sin excepci√≥n):\n   - executive_summary (>= 30 chars)\n   - readiness_criteria_min: 6‚Äì12 √≠tems\n   - checkpoints_obligatorios: 5‚Äì12 √≠tems\n   - gaps_blocking_ready:\n       ‚Ä¢ si brief_ready=false => m√≠nimo 1 √≠tem\n       ‚Ä¢ si brief_ready=true  => debe ser [] (0 √≠tems) salvo que existan supuestos cr√≠ticos (en cuyo caso brief_ready NO puede ser true)\n   - key_dependencies: m√≠nimo 1 √≠tem (si no hay, convi√©rtelo en gap y pregunta owner/fecha)\n   - key_risks: m√≠nimo 1 √≠tem (si no hay, convi√©rtelo en gap y pregunta guardrails)\n   - recommended_kpis: m√≠nimo 3 √≠tems (operables; ideal con umbral)\n   - sprint_plan: m√≠nimo 3 sprints (recomendado SP00, SP01, SP02)\n       ‚Ä¢ goals: array 2‚Äì6\n       ‚Ä¢ deliverables: array 2‚Äì8\n       ‚Ä¢ SP01 debe describir el PILOTO pr√°ctico y medible en deliverables\n   - user_stories: m√≠nimo 6 historias con hours_range (min/max) y acceptance (2‚Äì6)\n   - macro_estimation_hours_total_range: SIEMPRE calculado (min/max) como suma de user_stories\n   - preguntas concretas (A1..Ax) para cerrar faltantes (en el campo questions)\n   - next_user_instruction: texto claro (‚ÄúResponde A1..A3 y luego escribe /after‚Äù o ‚ÄúEscribe /briefejecutivo‚Äù)\n   - (NUEVO) Si brief_ready=true debes incluir SIEMPRE:\n       ‚Ä¢ impact_scorecard (5 dimensiones: Roles, Procesos, Estrategia, Cliente, Tecnologia)\n       ‚Ä¢ impact_score_overall (promedio + estrellas)\n\n4) brief_ready:\n   - Si after_action=\"brief\": solo puede ser true si gaps_blocking_ready queda vac√≠o y hay definici√≥n suficiente para READY (sin supuestos cr√≠ticos).\n   - Si hay gaps => brief_ready=false.\n5) state:\n   - Si after_action=\"brief\" => state=\"after_brief\"\n   - Si after_action!=\"brief\":\n       ‚Ä¢ Puedes poner state=\"after_brief\" SOLO si brief_ready=true (luz verde anticipada por calidad de respuestas).\n       ‚Ä¢ En otro caso => state=\"after_refinement\"\n6) Lenguaje ejecutivo: trade-offs, dependencias, evidencia, foco en caja/FCF/OPEX + churn/NPS + demo-first.\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nC) L√≥gica de evaluaci√≥n de respuestas (luz verde a BRIEF)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n1) Considera como ‚Äúrespuestas del usuario‚Äù la mejor fuente disponible en este orden:\n   a) clarify_answers_text (si existe y tiene A1:/A2:/...)\n   b) _user_text (si tiene formato A1:/A2:/...)\n   c) si no hay respuestas, asume que est√°s en primera iteraci√≥n de refinamiento.\n\n2) Si hay respuestas:\n   - Interpreta A1..Ax como evidencias/decisiones para cerrar gaps.\n   - Actualiza gaps_blocking_ready eliminando los que quedaron resueltos.\n   - Si las respuestas cubren owners, fechas, umbrales KPI y dise√±o de piloto/guardrails => puedes poner brief_ready=true y state=\"after_brief\" aunque after_action sea refine/continue.\n\n3) Para marcar brief_ready=true debes confirmar (con evidencia del texto o supuestos expl√≠citos NO cr√≠ticos):\n   - KPI operables con definici√≥n y umbral o target (m√≠n 3).\n   - Dependencia #1 con owner y entregable verificable.\n   - Riesgos principales con guardrails/kill-switch/rollback.\n   - SP01 incluye piloto medible (m√©trica, duraci√≥n, criterio de √©xito).\n   - Ready m√≠nimo: trazabilidad de medici√≥n + activaci√≥n + compliance (o supuestos de bajo riesgo con validaci√≥n r√°pida).\n\n4) Si brief_ready=false:\n   - gaps_blocking_ready debe tener m√≠nimo 1 √≠tem.\n   - questions debe tener m√≠nimo 3 (m√°x 8), redactadas como ‚ÄúA1: ...‚Äù pero en el campo questions SOLO va el texto de la pregunta (sin ‚ÄúA1:‚Äù literal si no quieres; el builder lo agrega).\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nD) Reglas cr√≠ticas reforzadas (STRICT + anti-vac√≠os + anti-loop + outputparser)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n0) OUTPUT STRICT (regla #0)\n- Devuelve SOLO JSON v√°lido conforme al schema (Structured Output) after_v2_1.\n- Prohibido: markdown, texto extra, wrappers, comentarios, backticks, explicaciones, ‚Äúaqu√≠ est√°‚Äù.\n- Prohibido: campos adicionales (additionalProperties=false). Solo lo permitido por el schema.\n\n1) CHAT_ID (obligatorio, sin excepci√≥n)\n- Debes COPIAR EXACTAMENTE el chat_id recibido en la entrada y devolverlo en \"chat_id\".\n- Prohibido devolver chat_id null, vac√≠o, ‚Äúunknown‚Äù, o inventado.\n- Si no recibes chat_id en la entrada:\n  - state=\"after_refinement\"\n  - brief_ready=false\n  - gaps_blocking_ready debe incluir: \"Falta chat_id en la entrada: corregir mapeo upstream para responder por Telegram.\"\n  - questions debe incluir (m√≠n 3): pedir confirmaci√≥n de chat_id + validar nodo normalize/post-merge.\n\n2) FEATURE_TITLE (obligatorio)\n- feature_title: nombre corto ejecutivo (>= 6 chars). No comandos, no ‚Äúidea: ‚Ä¶‚Äù, no frases largas.\n- Debe ser estable entre iteraciones (no renombrar cada /after).\n\n3) IDEA_TEXT (higiene cr√≠tica)\n- idea_text debe ser SIEMPRE la idea base.\n- Prohibido que idea_text contenga:\n  - comandos: /after, /brief, /briefejecutivo, /continue, /clarify, /reset\n  - respuestas del usuario: A1..Ax, Q1..Qx\n  - texto de ‚Äúpreguntas‚Äù o ‚Äúrespuestas‚Äù\n- Si la entrada trae _user_text con comando/respuestas, debes reconstruir idea_text usando:\n  - la idea base recibida (idea_text upstream)\n  - o la √∫ltima idea persistida (si te la pasan como contexto)\n  - Nunca uses el comando como idea.\n\n4) PROHIBIDO usar ‚Äúpendiente‚Äù (anti-basura)\n- Prohibido: ‚Äúpendiente‚Äù, ‚Äúpor definir‚Äù, ‚Äúno informado‚Äù, ‚Äúno disponible‚Äù, ‚Äútbd‚Äù, ‚Äún/a‚Äù o equivalentes.\n- Prohibido entregar listas vac√≠as cuando el schema o las reglas exigen m√≠nimos.\n- Si falta info, NO inventes datos:\n  - convi√©rtelo en gaps_blocking_ready como supuesto cr√≠tico verificable\n  - y genera questions accionables (owner/fecha/umbral/evidencia)\n\n5) COHERENCIA CON EL OUTPUTPARSER (m√≠nimos obligatorios)\nDebes producir SIEMPRE (sin excepci√≥n) y cumplir:\n- executive_summary: string >= 30 chars (ejecutivo, foco GTM, evidencia y trade-offs)\n- readiness_criteria_min: 6‚Äì12 strings (>=10 chars c/u)\n- checkpoints_obligatorios: 5‚Äì12 strings (>=10 chars c/u)\n- key_dependencies: 1‚Äì12 strings (>=10 chars c/u)\n- key_risks: 1‚Äì12 strings (>=10 chars c/u)\n- recommended_kpis: 3‚Äì12 strings (>=10 chars c/u) con:\n  f√≥rmula/definici√≥n + umbral + ventana + fuente + frecuencia (cuando aplique)\n- sprint_plan: 3‚Äì6 objetos con:\n  sprint: \"SP00\", \"SP01\", \"SP02\" (m√≠nimo) y opcional SP03..SP05\n  goals: 2‚Äì6\n  deliverables: 2‚Äì8\n  *SP01 debe ser el PILOTO pr√°ctico con deliverables medibles y evidencia*\n- brief.objectives: 3‚Äì8 strings (>=10 chars)\n- user_stories: 6‚Äì20 con:\n  id, title, description, size, hours_range(min/max), acceptance(2‚Äì6)\n- questions: 0‚Äì8 strings (>=12 chars c/u)\n- next_user_instruction: string >= 12 chars\n- (NUEVO) Si brief_ready=true debes producir:\n  - impact_scorecard (exactamente 5 √≠tems, uno por dimensi√≥n)\n  - impact_score_overall (avg + estrellas)\n\n6) REGLA DE GAPS + QUESTIONS (condicional del schema allOf)\n- Si brief_ready=false:\n  - gaps_blocking_ready: minItems=1\n  - questions: minItems=3\n- Si brief_ready=true:\n  - gaps_blocking_ready DEBE ser [] (maxItems=0)\n  - questions recomendado [] para brief\n\n7) MACRO_ESTIMATION_HOURS_TOTAL_RANGE (siempre calculado)\n- macro_estimation_hours_total_range debe ser SIEMPRE la suma de hours_range de user_stories:\n  - min = Œ£ stories.hours_range.min\n  - max = Œ£ stories.hours_range.max\n- Prohibido inventar rangos sin basarte en la suma.\n- Si detectas inconsistencia, convi√©rtelo en gap + pregunta, pero igual debes entregar un rango calculable.\n\n8) CONTROL DE FLUJO /after ‚Üí /briefejecutivo (anti-loop + ‚Äúbuenas respuestas pasan‚Äù)\n- after_action puede ser: refine | continue | brief (seg√∫n entrada).\n- Si llega clarify_answers_text (A1..Ax):\n  - Debes evaluar si las respuestas cierran gaps cr√≠ticos.\n  - Si las respuestas son buenas y permiten READY sin supuestos cr√≠ticos:\n    - state=\"after_brief\"\n    - brief_ready=true\n    - gaps_blocking_ready=[]\n    - questions=[]\n    - next_user_instruction=\"Escribe /briefejecutivo\"\n  - Si NO alcanzan:\n    - state=\"after_refinement\"\n    - brief_ready=false\n    - gaps_blocking_ready (solo lo que falta)\n    - questions (solo lo que falta, 3‚Äì8)\n\n9) L√çMITE DE ITERACIONES (no quedarse pegado en /after)\n- No repitas el mismo set de questions si el usuario no cambi√≥ informaci√≥n.\n- En m√°ximo 2 rondas de /after SIN progreso:\n  - reduce preguntas a las 3 m√°s cr√≠ticas con evidencia/owner/fecha\n  - o si ya hay definici√≥n suficiente, aprueba brief_ready=true\n- Si el usuario responde con alta calidad en la primera iteraci√≥n, puedes pasar directo a brief.\n\n10) NEXT_USER_INSTRUCTION (contrato duro)\n- Si brief_ready=true: next_user_instruction DEBE ser exactamente:\n  \"Escribe /briefejecutivo\"\n- Si brief_ready=false: next_user_instruction DEBE guiar as√≠:\n  \"Responde A1..Ax y luego escribe /after\"\n  (Ax coherente con cantidad real de questions; no exceder 8)\n\n11) STATE (contrato duro)\n- Si brief_ready=true => state=\"after_brief\"\n- En otro caso => state=\"after_refinement\"\n- No uses otros values.\n\n12) LENGUAJE EJECUTIVO (OPT)\n- Enfoca en caja/FCF/OPEX + churn/NPS + demo-first.\n- Todo debe ser verificable: owner/fecha/entregable/criterio o f√≥rmula/umbral/fuente/frecuencia.\n- Trade-offs expl√≠citos: impacto vs riesgo vs dependencia.\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nE) Cierre de calificaci√≥n (NUEVO) ‚Äî Impacto en Estrellas\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nObjetivo:\nAl entregar un BRIEF listo (brief_ready=true) debes incluir una calificaci√≥n del impacto organizacional para visualizar cada Brief con ‚Äúestrellas‚Äù.\n\nDimensiones (exactamente estas 5):\n- Roles\n- Procesos\n- Estrategia\n- Cliente\n- Tecnologia\n\nEscala (1 a 5):\n1 = Impacto marginal/local: afecta a un equipo o un tramo peque√±o, sin cambio relevante de operating model.\n2 = Mejora acotada: mejora un proceso parcial, bajo efecto en KPIs globales.\n3 = Impacto relevante: multi-equipo o E2E parcial, impacto medible en 1‚Äì2 KPIs.\n4 = Impacto transversal: cambia pr√°cticas/operaci√≥n E2E, requiere adopci√≥n estructurada, impacto claro en KPIs core.\n5 = Impacto full: cambio de operating model o capacidad estrat√©gica, replicable a escala, con efecto material en KPIs y forma de trabajo.\n\nReglas para construir scorecard:\n- Cada dimensi√≥n debe tener:\n  ‚Ä¢ score entero 1..5\n  ‚Ä¢ stars string EXACTAMENTE 5 caracteres en formato: \"‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ\" (siempre 5)\n  ‚Ä¢ rationale breve (por qu√© ese score con base en el Brief)\n- El promedio overall (avg) debe ser calculado como media simple de los 5 scores (puede tener 1 decimal).\n- overall_stars debe mapear avg a estrellas (redondeo al entero m√°s cercano):\n  1‚Üí‚òÖ‚òÜ‚òÜ‚òÜ‚òÜ  2‚Üí‚òÖ‚òÖ‚òÜ‚òÜ‚òÜ  3‚Üí‚òÖ‚òÖ‚òÖ‚òÜ‚òÜ  4‚Üí‚òÖ‚òÖ‚òÖ‚òÖ‚òÜ  5‚Üí‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ\n\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nF) CHECKLIST FINAL (antes de responder)\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n- ¬øEl JSON valida contra after_v2_1 strict? (sin campos extra)\n- ¬øchat_id est√° presente y copiado?\n- ¬øidea_text NO contiene comandos ni A1..Ax?\n- ¬ømacro_estimation_hours_total_range = suma exacta de user_stories?\n- ¬øsprint_plan.sprint usa SP00..SP02?\n- ¬øbrief_ready=false => gaps>=1 y questions>=3?\n- ¬øbrief_ready=true => gaps=[] y next_user_instruction=\"Escribe /briefejecutivo\"?\n- ¬øSi brief_ready=true incluiste impact_scorecard (5) + impact_score_overall (avg+stars)?\n- ¬øNo existe la palabra ‚Äúpendiente‚Äù ni equivalentes?\n",
          "returnIntermediateSteps": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.2,
      "position": [
        -1776,
        2272
      ],
      "id": "74d0d200-e7c0-48a6-a07f-25d4868cc588",
      "name": "LLM AFTER Agent COE"
    },
    {
      "parameters": {
        "jsCode": "/**\n * Build Telegram Response ‚Äî command reminder v1.0\n * - Envia recordatorio cuando falta comando (/continue, /after, /refinebrief, /briefejecutivo)\n *\n * Input: $json.output\n * Output: $json.output.telegram.send_text + chat_id\n */\n\nfunction normStr(s){ return (s ?? \"\").toString().trim(); }\nfunction isObj(v){ return typeof v === \"object\" && v !== null && !Array.isArray(v); }\n\nconst inItems = $input.all();\nconst out = [];\n\nfor (const it of inItems) {\n  const root = isObj(it.json) ? it.json : {};\n  const o = isObj(root.output) ? root.output : {};\n  const chat_id = normStr(o.chat_id || \"\");\n  const prompt = normStr(o.reminder_prompt || \"\");\n  const msg = prompt || \"Recib√≠ tu respuesta. Por favor acomp√°√±ala con un comando: /continue (Alignment), /after (refinar), /refinebrief (refinar + brief) o /briefejecutivo (brief).\";\n\n  if (!isObj(o.telegram)) o.telegram = {};\n  o.telegram.chat_id = chat_id;\n  o.telegram.send_text = msg;\n\n  root.output = o;\n  out.push({ json: root });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -64,
        2304
      ],
      "id": "8de7dd4d-63d3-40d1-bcfa-f0722042d706",
      "name": "Build Telegram Response ‚Äî command reminder"
    }
  ],
  "pinData": {
    "Telegram Trigger Delta": [
      {
        "json": {
          "update_id": 705653015,
          "message": {
            "message_id": 1677,
            "from": {
              "id": 5656055088,
              "is_bot": false,
              "first_name": "32790",
              "language_code": "en"
            },
            "chat": {
              "id": 5656055088,
              "first_name": "32790",
              "type": "private"
            },
            "date": 1767973750,
            "text": "/after",
            "entities": [
              {
                "offset": 0,
                "length": 6,
                "type": "bot_command"
              }
            ]
          }
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "connections": {
    "Telegram Trigger Delta": {
      "main": [
        [
          {
            "node": "TG Pre-route Normalizer + Edits2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "TG Pre-route Normalizer + Edits2": {
      "main": [
        [
          {
            "node": "Switch Route",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch Route": {
      "main": [
        [
          {
            "node": "LLM Alignment Engine AGILIDAD",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Merge LLMs",
            "type": "main",
            "index": 1
          }
        ],
        [
          {
            "node": "LLM AFTER Agent COE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge LLMs": {
      "main": [
        [
          {
            "node": "Post-Merge Organizer + Switch Enricher3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post-Merge Organizer + Switch Enricher3": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "Build Telegram Response ‚Äî alignment.after_refine1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Telegram Response alignment.clarify",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Telegram Response alignment.discard",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Telegram Response after.after_refinment1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Telegram Response Greeting",
            "type": "main",
            "index": 0
          }
        ],
        [],
        [
          {
            "node": "Build Telegram Response ‚Äî command reminder",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build Telegram Response ‚Äî after.after_brief",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Build HTML Brief Ejecutivo",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Telegram Response Greeting": {
      "main": [
        [
          {
            "node": "greeting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Telegram Response alignment.clarify": {
      "main": [
        [
          {
            "node": "alignment.clarify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Telegram Response ‚Äî after.after_brief": {
      "main": [
        [
          {
            "node": "after.after_brief",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build HTML Brief Ejecutivo": {
      "main": [
        [
          {
            "node": "SendGrid Email (AFTER Brief)3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Telegram Response alignment.discard": {
      "main": [
        [
          {
            "node": "alignment.discard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Msg Splitter2": {
      "main": [
        [
          {
            "node": "after.after_refinement",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Msg Splitter3": {
      "main": [
        [
          {
            "node": "alignment.after_refine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Telegram Response after.after_refinment1": {
      "main": [
        [
          {
            "node": "Msg Splitter2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Telegram Response ‚Äî alignment.after_refine1": {
      "main": [
        [
          {
            "node": "Msg Splitter3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI LLM AFTER Agent6": {
      "ai_languageModel": [
        [
          {
            "node": "LLM AFTER Agent COE",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory LLM AFTER Agent6": {
      "ai_memory": [
        [
          {
            "node": "LLM AFTER Agent COE",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser LLM AFTER Agent5": {
      "ai_outputParser": [
        [
          {
            "node": "LLM AFTER Agent COE",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI LLM Alignment Engine5": {
      "ai_languageModel": [
        [
          {
            "node": "LLM Alignment Engine AGILIDAD",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory LLM Alignment Engine5": {
      "ai_memory": [
        [
          {
            "node": "LLM Alignment Engine AGILIDAD",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser LLM Alignment Engine4": {
      "ai_outputParser": [
        [
          {
            "node": "LLM Alignment Engine AGILIDAD",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "LLM Alignment Engine AGILIDAD": {
      "main": [
        [
          {
            "node": "Merge LLMs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM AFTER Agent COE": {
      "main": [
        [
          {
            "node": "Merge LLMs",
            "type": "main",
            "index": 2
          }
        ]
      ]
    },
    "Build Telegram Response ‚Äî command reminder": {
      "main": [
        [
          {
            "node": "alignment.clarify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "b7240b8c-17db-48a9-b5b0-fc9de91eb0a6",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "e108a692467998ab132d8b6dcd917a78a5bbb510d04136898d9bc76c7f813eef"
  },
  "id": "N9HBKjHKh3tODGPr",
  "tags": []
}